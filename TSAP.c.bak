/*  TSAP.c  - this file auto generated by tools */

/* modification history
-----------------------

01a 2021-03-05 19:41:34     auto create by autogen moban tool
*/

/*
<autogen moban tool>
  author: frank
  bug report: frank_zhou@163.com
*/



#define   TSAP_C

#include   <windows.h>

#include   "DTXA.h"
#include   "TSAP.h"
#include   "golytec.h"
#include   "mio.h"
#include   "network.h"
#include   "GFXA.h"
#include "libTSXA.h"



BOOL g_TSXA_auto_pos_err_reset = FALSE;     // 是否自动auto pos err reset


UINT16 g_RF_seq = 1;    // RF seq 




BOOL g_network_initialized = FALSE;

// MIO UDP server ip
char g_server_ip[32] = "192.168.1.222";    // 如有udp.ini文件，则以udp.ini配置文件中的为准
char g_client_ip[32] = "192.168.1.188";          // client任意ip   
int g_port_begin = 2900;

// 网络是否已初始化
BOOL g_network_inited = FALSE;

// 通信端口
NET_PORT_ADMIN_STRUCT g_port_admin[NET_SOCKET_MAX_NUM] = { 0 };

HANDLE g_its_udp_sem = NULL;


// mio常用读取的系统寄存器
UINT32 g_mio_sys_status_reg;    // 系统状态  0x1000   
UINT32 g_mio_sys_errno_reg;         // sys error no 0x1004
UINT32 g_mio_sys_errinfo_reg;   // err info  0x102c
tsap_mio_stn_status_reg_struct   g_mio_stn_status_reg;

// 刷新寄存器时的调用rtn，要传回给外部接口函数
int  g_TSAP_flush_sys_status_rtn = 0;
int  g_TSAP_flush_stn_status = 0;



// forward defines
int send_header_data_packeg(IN int send_data_size, IN int func_code, IN int addr, IN int size, OUT UINT8 *out, OUT int *outLen );
int eth_read_config_data(void);
int TSAP_get_mover_pos
        (
        IN      int     axis,
        OUT     double  *pos,
        OUT     double  *vel
        );



/* 任务退出需要做的清理工作 */
int TSAP_MA_task_exit(void)
{
    int rtn = OK;

    return rtn;
}

/* 具体函数实现需要组件内部填写，这里仅列出所有与外部接口对应的TSAP_xxx函数 */


int its_udp_lock(void)
{
    int rtn = OK;
    
//    rtn = GFXA_semTake_mutex(g_its_udp_sem, 30000);

    return rtn;
}


int its_udp_unlock(void)
{
    int rtn = OK;

//    rtn = GFXA_semGive_mutex(g_its_udp_sem);
    
    return rtn;
}


// 根据线程id，获取相应的通信端口，每个线程使用一个端口
int network_get_port_fd_from_tid(OUT int *fd, OUT int *index)
{
    int rtn = OK;
    int i = 0;
    UINT32 tid = 0;
    BOOL found = FALSE;
    int io_fd = 0;
    int io_index = 0;

//    io_fd = g_port_admin[io_index].fd;      // 直接用第一个
//    found = TRUE;

    
#if 1
    // 获取线程id
    tid = GetCurrentThreadId();

    if( OK == rtn )
    {
        // 查找线程已经占用的fd
        for( i = 0; i < NET_SOCKET_MAX_NUM; i++ )
        {
            if( ( g_port_admin[i].tid == tid ) && ( g_port_admin[i].fd != 0 ) )
            {
                found = TRUE;
                io_fd = g_port_admin[i].fd;
                io_index = i;
                break;
            }
        }

        // 没有找到的话，就找一个空位占据
        if( !found )
        {
            for( i = 0; i < NET_SOCKET_MAX_NUM; i++ )
            {
                if( g_port_admin[i].tid == 0 )
                {
                    g_port_admin[i].tid = tid;
                    io_fd = g_port_admin[i].fd;
                    io_index = i;
                    found = TRUE;
                    break;
                }
            }
        }
    }

    if( !found )        // 端口已经全部占用，那就直接使用第0个
    {
        io_fd = g_port_admin[0].fd;
        io_index = 0;
    }
    
#endif

    if( OK == rtn )
    {
        if( found )
        {
            if( fd != NULL )
            {
                *fd = io_fd;
            }
            if( index != NULL )
            {
                *index = io_index;
            }
        }
        else
        {
            rtn = LMXA_SYSTEM_ERROR;
        }
    }

    // debug, add sby frank
//    printf("thread id: %d  fd: %d  index: %d\n", tid, io_fd, io_index);


    return rtn;
}




// 网络初始化
int network_init(void)
{
	int rtn = OK;
    WORD wVersionRequested;
    WSADATA wsaData;
    int io_fd = 0;
    int result = 0;
    u_long turn_on = TRUE;
    char one = 64;
    int buf_size = 0;
    int sockAddrSize = 0;
    struct sockaddr_in inet_server_addr;
    int err = 0;
    struct sockaddr_in client;
    int i = 0;
    int index = 0;

    //g_socket_id_sel = 0;

	// socket service init
    wVersionRequested = MAKEWORD(2, 0);
    err = WSAStartup(wVersionRequested, &wsaData);
    if( err != 0 )
    {
    	rtn = LMXA_INIT_SOCKET_SERVICE_ERROR;
    }

    if( OK == rtn )
    {
        memset((void *)g_port_admin, 0, sizeof(NET_PORT_ADMIN_STRUCT) * NET_SOCKET_MAX_NUM);
    }

    g_port_begin = LMXA_BEGIN_PORT;
#if 1
    if( OK == rtn )
    {
        eth_read_config_data();
    }
#endif

    if( OK == rtn )
    {
        //for( i = 0; i < 1; i++ )      
        for( i = 0; i < NET_SOCKET_MAX_NUM; i++ )        // 使用80个端口建立多个socket连接
        {
            if( 0 == g_port_admin[i].port )     // 如果为0，就使用默认的端口
            {
                g_port_admin[i].port = g_port_begin + i;
            }
            
            // create socket
        	if( OK == rtn )
        	{
            	memset(&inet_server_addr, 0, sizeof(inet_server_addr));

        		/* Create  socket */
            	//io_fd = socket( AF_INET, SOCK_STREAM, 0 );      // TCP
            	io_fd = socket( AF_INET, SOCK_DGRAM, 0 );       // UDP
            	if(io_fd < 0)
            	{
                	//err = WSAGetLastError();
                	//printf("can't open socket. errno = %d\n", err);
                	rtn = LMXA_CREATE_SOCKET_ERROR;
            	}
            }

        	// set socket parameter
        	if( OK == rtn )
        	{
            	turn_on = TRUE;
         //   	ioctlsocket( io_fd, FIONBIO, &turn_on );   // for non-blocking connect

            	// 填入socket相应的信息
            	sockAddrSize = sizeof(struct sockaddr_in);
            	inet_server_addr.sin_family = AF_INET;
            	inet_server_addr.sin_port = htons((UINT16)g_port_admin[i].port);

            	if((inet_server_addr.sin_addr.s_addr = inet_addr(g_server_ip) )== ERROR)
            	{
                	perror("unknown server name\n");
                	closesocket(io_fd);
                	rtn = LMXA_SET_SOCKET_PARAMETER_ERROR;
            	}

                // client bind port 
                client.sin_family = AF_INET;
                client.sin_port = htons((UINT16)g_port_admin[i].port);   
//                client.sin_port = htons((UINT16)g_port_admin[i].port + 10);	// 2020.10.4 frank modify temp
                client.sin_addr.s_addr = inet_addr(g_client_ip);
                if( bind(io_fd,  (SOCKADDR *)&client, sizeof(client)) == SOCKET_ERROR )
                {
                    perror("client bind error.\n");
                    closesocket(io_fd);
                    rtn = LMXA_SET_SOCKET_PARAMETER_ERROR;
                }
        	}

#if 0
        	// connet to server
        	if( OK == rtn )
        	{

            	result = connect( io_fd, (SOCKADDR *)&inet_server_addr, sizeof(inet_server_addr) );
            	if(result < 0)
            	{
                	err = WSAGetLastError();
                	if (err == WSAEINPROGRESS || err == WSAEALREADY || err == WSAEWOULDBLOCK )
                	{
                    	FD_ZERO (&writeFds);
                    	FD_SET (io_fd, &writeFds);

                    	time.tv_sec = 0;
                    	time.tv_usec = 100000;
                    	if (select (FD_SETSIZE, (fd_set *) NULL, &writeFds, (fd_set *) NULL, &time) > 0)
                    	{
                        	if (FD_ISSET (io_fd, &writeFds))
                        	{
                            	result = 0;
                        	}
                    	}
                    	else
                    	{
                        	result = -1;
                    	}
                	}
            	}

            	if(result < 0)
            	{
                	closesocket(io_fd);
                	rtn = LMXA_SERVER_NOT_LISTENING_ERROR;
            	}
        	}	
#endif

        	// set socket opt to blocking and keepalive
        	if( OK == rtn )
        	{
            	// Set io_fd back to blocking for further io
            	turn_on = FALSE;
            	ioctlsocket( io_fd, FIONBIO, &turn_on );
            	turn_on = TRUE;
            	result = setsockopt(io_fd, SOL_SOCKET, SO_KEEPALIVE, (char *)&turn_on, 4);
            	buf_size = 8192;
            	setsockopt(io_fd, SOL_SOCKET, SO_SNDBUF, (char *)&buf_size, 4);

            	g_port_admin[i].fd = io_fd;
        	}
        }
    }

    if( OK == rtn )
    {
        rtn = GFXA_semCreate_mutex("its_udp_net", &g_its_udp_sem);
    }

    if( OK == rtn )
    {
    	g_network_inited = TRUE;
    }

	return rtn;	
}


int network_WriteMsg( int write_fd, const void *msg, int len, int sock_id )
{
    int rtn = OK;
    int towrite = 0;
    int written = 0;
    int temp = 0;
    char *pMsg_buf = NULL;
    char *pTemp = NULL;
    struct sockaddr_in inet_server_addr;
	int err = 0;
    int sockAddrSize;
    char *func_name = "network_WriteMsg";
    

    	sockAddrSize = sizeof(struct sockaddr_in);
		memset((void *)&inet_server_addr, 0, sockAddrSize);
    	inet_server_addr.sin_family = AF_INET;
    	inet_server_addr.sin_port = htons((UINT16)g_port_admin[sock_id].port);

    	if((inet_server_addr.sin_addr.s_addr = inet_addr(g_server_ip) )== ERROR)
    	{
        	perror("unknown server name\n");
        	//closesocket(io_fd);
        	rtn = LMXA_SET_SOCKET_PARAMETER_ERROR;
    	}



	if( !g_network_inited )
	{
		rtn = LMXA_NOT_INIT_ERROR;
	}	

	if( OK == rtn )
	{
        pMsg_buf = (char *)malloc(len);
        if(pMsg_buf == NULL)
        {
            rtn = LMXA_SYSTEM_ERROR;
        }
        pTemp = pMsg_buf;
    }
    
    // Copy message to buffer
    if( OK == rtn )
    {
        memcpy(pMsg_buf, msg, len);
        towrite = len;

        while( towrite > 0 )
        {
            written = sendto(write_fd, (char *)pMsg_buf, towrite, 0, (struct sockaddr *)&inet_server_addr, sizeof(inet_server_addr));
            if(written == SOCKET_ERROR)        // if(error)  ???
            {
                free(pTemp);
				err = WSAGetLastError();
                if( err == WSAECONNRESET)
                {
                    closesocket(write_fd);
                    return LMXA_CONNECTION_RESET_ERROR;
                }
                else
                {
                    return LMXA_SYSTEM_ERROR;
//                    DTXA_trace_t("TS", DTXA_TRACE_INT, func_name, " call sendto() error 0x%x", err);
                }
            }

            towrite -= written;
            if( towrite > 0 )
            {
                pMsg_buf = pMsg_buf + written;
                //DN_LOG("  %d bytes have not writen. ",towrite,0,0,0,0,0);
            }
        }
    }

    // Free allocated message buffer
    free(pTemp);

    return rtn;
}


int network_recvMsg( int read_fd, const void *buf, int maxlen, int *len, int sock_id)
{
    int rtn = OK;
    int recvLen = 0;
    int socketrtn = 0;
    int sockAddrSize;
    int addrlen = 0;
    struct sockaddr_in inet_server_addr;
    struct timeval tv;
    char *func_name = "network_recvMsg";
    int timeout = 3000;
//    fd_set rfd;
    
	sockAddrSize = sizeof(struct sockaddr_in);
	memset((void *)&inet_server_addr, 0, sockAddrSize);
	inet_server_addr.sin_family = AF_INET;
	inet_server_addr.sin_port = htons((UINT16)g_port_admin[sock_id].port);

	if((inet_server_addr.sin_addr.s_addr = inet_addr(g_server_ip) )== ERROR)
	{
    	perror("unknown server name\n");
    	rtn = LMXA_SET_SOCKET_PARAMETER_ERROR;
	}

	addrlen = sizeof(inet_server_addr);

	if( !g_network_inited )
	{
		rtn = LMXA_NOT_INIT_ERROR;
	}	

#if 0
    if( OK == rtn )
    {
        tv.tv_sec = 3;
        tv.tv_usec = 0;    

        FD_ZERO(&rfd);
        FD_SET(read_fd, &rfd);
        
        rtn = select(0, &rfd, NULL, NULL, &tv);
        if( SOCKET_ERROR == rtn )
        {
            rtn = LMXA_SYSTEM_ERROR;
        }
        else if( 0 == rtn )
        {
            rtn = LMXA_RECV_TIMOUT;
        }
        else    
        {
            recvLen = recvfrom(read_fd, (char *)buf, maxlen, 0, (SOCKADDR *)&inet_server_addr, &addrlen);
            if ( recvLen < 0) 
            {
    			socketrtn = WSAGetLastError();
                if (WSAETIMEDOUT == socketrtn)
                {
                    rtn = LMXA_RECV_TIMOUT;
                }
                else
                {
                    rtn = LMXA_SYSTEM_ERROR;
                }
            }
        }
    }
#endif

#if 1
    if( OK == rtn )
    {
        tv.tv_sec = 3;
        tv.tv_usec = 0;        
        setsockopt(read_fd, SOL_SOCKET, SO_RCVTIMEO, (char*)&tv, sizeof(tv));
 //       setsockopt(read_fd, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout, sizeof(timeout));
		recvLen = recvfrom(read_fd, (char *)buf, maxlen, 0, (SOCKADDR *)&inet_server_addr, &addrlen);
        if ( recvLen < 0) 
        {
			socketrtn = WSAGetLastError();
            if (WSAETIMEDOUT == socketrtn)
            {
                rtn = LMXA_RECV_TIMOUT;
            }
            else
            {
                rtn = LMXA_SYSTEM_ERROR;
            }
        }
    }
#endif 

    if( len != NULL )
    {
        *len = recvLen;
    }

    return rtn;
}


int network_terminate_s(void)
{
    int rtn = OK;
    char *func_name = "RS485_terminate_s";
    BOOL simMode = FALSE;
    int i = 0;

    if( g_network_initialized )
    {
        for( i = 0; i < NET_SOCKET_MAX_NUM; i++ )
        {
            if( g_port_admin[i].fd != 0 )
            {
                closesocket(g_port_admin[i].fd);
                g_port_admin[i].fd = 0;
                g_port_admin[i].tid = 0;
            }
        }

        // 关闭互斥信号量
        if( g_its_udp_sem != NULL )
        {
            CloseHandle(g_its_udp_sem);
            g_its_udp_sem = NULL;
        }

        g_network_initialized = FALSE;
    }

    return rtn;
}


int network_initialize_s( void )
{
	int rtn = OK;
    char sem_name[32] = { 0 };
    char *func_name = "network_initialize_s";


    if( !g_network_initialized )
    {
        rtn = network_init();
    }
    
    if( OK == rtn )
    {
        g_network_initialized = TRUE;
    }


    return rtn;
}



// 读取数据区的数据内容
int network_read_data_s
                            (
                            IN int addr,                // 读取的数据在数据区的地址
                            IN int size,                // 读取的数据大小，单位字节
                            OUT UINT8 *data,             // 读取的数据缓存
                            OUT int *act_len            // 实际读取到的字节数
                            )
{
    int rtn = OK;
    UINT8 buf[MAX_FRAME_SIZE] = { 0 };
    UINT8 recv[MAX_FRAME_SIZE] = { 0 };
    int sendLen = 0;
    int i = 0;
    int j = 0;
    char *func_name = "network_read_data_s";
    int fd = 0;
    int index = 0;
    int func_code = 0;
    int header_size = 0;
    int max_len = 0;
    int bytes = 0;
    int recv_bytes = 0;


    // 未初始化，进行初始化
    if( !g_network_initialized )
    {
        rtn = network_initialize_s();
    }


    // 参数检查
    if( size > 1024 ) 
    {
        rtn = LMXA_PARAMETER_ERROR;
//        EEXA_log_error(rtn, NULL, __FILE__, __LINE__,
//            "network_read_data_s(size = %d) parameter error", size);
    }

    // 数据打包
    if( OK == rtn )
    {
        func_code = 0x0001;
        rtn = send_header_data_packeg(0, func_code, addr, size, buf, &header_size);
    }

    if( OK == rtn )
    {
        rtn = network_get_port_fd_from_tid(&fd, &index);
    }

    if( OK == rtn )
    {
//        its_udp_lock();
        rtn = network_WriteMsg(fd, (void *)buf, header_size, index);
//        its_udp_unlock();
    }

    // 读取回应数据
    if( OK == rtn )
    {
        Sleep(1);
        for( j = 0; j < 3; j++)     
    	{
            // windows UDP单个数据包最大1k
            max_len = MAX_FRAME_SIZE;
//            its_udp_lock();
            rtn = network_recvMsg(fd, recv, max_len, &bytes, index);
            if( ( OK == rtn ) && ( bytes > 32 ) && (bytes <= MAX_FRAME_SIZE ) )  // 正常接收到数据 
            {
                recv_bytes += bytes;
                memcpy( (void *)data, (void *)&recv[32], bytes - 32 );      // 去掉32字节的头部信息
                break;
        	}
            Sleep(1);
//            its_udp_unlock();

        }
    }

    return rtn;
}



// 写入数据到数据区
int network_write_data_s
                            (
                            IN int addr,                // 写入的数据在数据区的地址
                            IN int size,                // 写入的数据大小，bytes
                            IN UINT8 *data              // 写入的数据缓存
                            )
{
    int rtn = OK;
    UINT8 buf[MAX_FRAME_SIZE] = { 0 };
    UINT8 recv[32] = { 0 };
    int bytes = 0;
    int fd = 0;
    int index = 0;
    int func_code = 0;
    int header_size = 0;
    UINT32 error = 0;
    int i = 0;


    // 未初始化，进行初始化
    if( !g_network_initialized )
    {
        rtn = network_initialize_s();
    }

    // 参数判断处理
    if( size > MAX_FRAME_SIZE ) 
    {
        rtn = LMXA_PARAMETER_ERROR;
//        EEXA_log_error(rtn, NULL, __FILE__, __LINE__,
//            "RS485_write_data_s(size = %d) parameter error", size);
    }

    if( OK == rtn )
    {
        // 数据打包
        func_code = 0x1001;
        rtn = send_header_data_packeg(size, func_code, addr, size, buf, &header_size);
        memcpy(( void *)&buf[32], (void *)data, size);
    }

    if( OK == rtn )
    {
        rtn = network_get_port_fd_from_tid(&fd, &index);
    }


    if( OK == rtn )
    {
//        its_udp_lock();
        rtn = network_WriteMsg(fd, (void *)buf, size+32, index);
//        its_udp_lock();
    }

    
#if 1    // removed by frank 2020.12.11
    // 等待回应
    if( OK == rtn )
    {
    //    	its_udp_lock();
        for( i = 0; i < 3; i++ )
        {
            Sleep(1);
        	// 读取回应内容
            rtn = network_recvMsg(fd, (void *)recv, 32, &bytes, index);
        	if( ( rtn == OK ) && ( bytes == 32  ) )        // 正常接收到回应数据
        	{
                memcpy((void *)&error, (void *)&recv[20], 4);
                rtn = error;
                break;
            }
            else 
            {
                // EEXA_log_error(rtn, NULL, __FILE__, __LINE__, "UART_async_read_COM() recv ACK error");
            }
            Sleep(1);
        }

//        its_udp_lock();
    }
#endif
  
    return rtn;
}



// 将数据包头进行打包
int send_header_data_packeg(IN int send_data_size, IN int func_code, IN int addr, IN int size, OUT UINT8 *out, OUT int *outLen )
{
    int rtn = OK;
    UINT32 msg_len = 0;
    UINT32 protocol = 0;
    UINT32 seq = 0;
    UINT32 nc_code = 0;
    UINT32 reply = 0;
    UINT32 net_addr = 0;
    UINT32 net_size = 0;
    UINT32 net_func_code = 0;
    UINT8  buf[2048] = { 0 };
    int index = 0;

    msg_len = 32 + send_data_size;
    protocol = 0x474f4c59;
    seq =  0x54454300;
    nc_code = 0x4a494e59;
    reply = 0x1;
    net_addr = addr;
    net_size = size;
    net_func_code = func_code;
    
    if( out != NULL )
    {
        // msg_len
        memcpy((void *)buf, (void *)&msg_len, sizeof(msg_len) );
        index += sizeof(UINT32);

        // protocol
        memcpy((void *)&buf[index], (void *)&protocol, sizeof(msg_len) );
        index += sizeof(UINT32);

        // seq
        memcpy((void *)&buf[index], (void *)&seq, sizeof(msg_len) );
        index += sizeof(UINT32);

        // nc_code
        memcpy((void *)&buf[index], (void *)&nc_code, sizeof(msg_len) );
        index += sizeof(UINT32);

        // func_code
        memcpy((void *)&buf[index], (void *)&net_func_code, sizeof(msg_len) );
        index += sizeof(UINT32);

        // reply
        memcpy((void *)&buf[index], (void *)&reply, sizeof(msg_len) );
        index += sizeof(UINT32);

        // addr
        memcpy((void *)&buf[index], (void *)&net_addr, sizeof(msg_len) );
        index += sizeof(UINT32);

        // size
        memcpy((void *)&buf[index], (void *)&net_size, sizeof(msg_len) );
        index += sizeof(UINT32);

        // output
        memcpy((void *)out, (void *)buf, index);
    }

    if( outLen != NULL )
    {
        *outLen = index;
    }

    return rtn;
}


int eth_read_config_2_var(IN char *name, IN char *value)
{
    int rtn = OK;
    int num = 0;
    int i = 0;
    int j = 0;

    if( strstr(name, "udp_server") != NULL )
    {
        memset((void *)g_server_ip, 0, sizeof(g_server_ip));
        strcpy(g_server_ip, value);
    }
    else if( strstr(name, "udp_client") != NULL )
    {
        memset((void *)g_client_ip, 0, sizeof(g_client_ip));
        strcpy(g_client_ip, value);
    }
    else if( strstr(name, "port0") != NULL )
    {
        g_port_admin[0].port = atoi(value);
    }
    else if( strstr(name, "port1") != NULL )
    {
        g_port_admin[1].port = atoi(value);
    }
    else if( strstr(name, "port2") != NULL )
    {
        g_port_admin[2].port = atoi(value);
    }
    else if( strstr(name, "port3") != NULL )
    {
        g_port_admin[3].port = atoi(value);
    }
    else if( strstr(name, "port4") != NULL )
    {
        g_port_admin[4].port = atoi(value);
    }
    else if( strstr(name, "port5") != NULL )
    {
        g_port_admin[5].port = atoi(value);
    }
    else if( strstr(name, "port6") != NULL )
    {
        g_port_admin[6].port = atoi(value);
    }
    else if( strstr(name, "port7") != NULL )
    {
        g_port_admin[7].port = atoi(value);
    }
    else if( strstr(name, "port_begin") != NULL )
    {
        g_port_begin = atoi(value);
    }
    
    return rtn;
}



// 将字符串进行分割
int eth_break_string_to_substr(IN char *buf, IN char *space, 
								OUT char *buf1, OUT char *buf2, OUT char *buf3, OUT char *buf4)
{
    int i = 0;
    int j = 0;
    int rtn = OK;
	char *token = NULL;
    char tempstring[400];
	//    char whitespace[] = " );\t\f\r\v\n";
	
    if( strlen(buf) > sizeof(tempstring) )
    {
        return -1;
    }
	
    memset((void *)tempstring, 0, sizeof(tempstring));
    strcpy(tempstring, buf);
	
	for( j = 0, token = strtok(tempstring, space);
	(token != NULL) && (j < 4);
	token = strtok(NULL, space), j++ )
	{
		switch(j)
		{
		case 0:
			sprintf(buf1, "%s", token);
			break;
		case 1:
			sprintf(buf2, "%s", token);
			break;
		case 2:
			sprintf(buf3, "%s", token);
			break;
		case 3:
			sprintf(buf4, "%s", token);
			break;
		default:
			break;
		}
	}
	
    return rtn;
}



// 读取 upd.ini配置文件
int eth_read_config_data(void)
{
	int rtn = OK;
    FILE *fp = NULL;
    int i = 0;
    int j = 0;
    char ch = 0;
    int row = 0;
    char tempstring[160];   // 存放文件中的一整行信息
    char temp1[80];         // 存放type
    char temp2[80];         // 存放name
    char temp3[80];         // 存放value
	char temp4[80];         // 存放 comment
    int num = 0;

    static char whitespace[] = " ,;:=\t\f\r\v\n";
    char *token = NULL;

    fp = fopen("udp.ini", "r");
    if(fp == NULL)
    {
		return (-1);
    }

    while((ch = getc(fp)) != EOF)
    {
        if(ch == '\n')
        {
            row++;
        }
    }

    fseek(fp, 0, SEEK_SET);

    for(i = 0; i < row; i++)
    {
        memset(tempstring, 0, sizeof(tempstring));

        for(j=0; (ch = getc(fp)) != '\n'; j++)
        {
            tempstring[j] = ch;
        }
        tempstring[j] = '\0';

        // 现在tempstring[]放的是一整行信息
        if( tempstring[0] == '/' && tempstring[1] == '/' )          // 行首为//表示注释行，忽略
        {
            continue;
        }
        
		memset((void *)temp1, 0, sizeof(temp1));
		memset((void *)temp2, 0, sizeof(temp2));
		memset((void *)temp3, 0, sizeof(temp3));
		memset((void *)temp4, 0, sizeof(temp4));
  		eth_break_string_to_substr(tempstring, whitespace, temp1, temp2, temp3, temp4 );

        // temp1[]放的是name
        // temp2[]放的是data
        eth_read_config_2_var(temp1, temp2);

    }

    fclose(fp);
    
	return rtn;
}





int MIO_read_reg
        (
        IN      int     addr,
        OUT     UINT32  *value
        )
{
	int rtn = OK;
    int actlen = 0;
    int i = 0;
    int index = 0;
    char *func_name = "TSAP_MIO_read_reg";
    int link_err[2] = { 0 };
    unsigned char buf[128] = { 0 };
    UINT32 var = 0;

    // 入口trace，需要人工检查修改
    DTXA_trace_t("TS", DTXA_TRACE_INT, func_name, "> (addr = 0x%x)", addr);

//its_udp_lock();
    if( OK == rtn )
    {
        for(i = 0; i < 3; i++ )
        {
            rtn = network_read_data_s(addr, 4, buf, &actlen);
            if( rtn != OK )
            {
                if( i > 0 )     // 错误次数大于1次后才记录
                {
                    link_err[0] = rtn;
                    link_err[1] = 0;
                    rtn = MIO_RS485_READ_ERROR;
//                    EEXA_log_error(rtn, link_err, __FILE__, __LINE__,
//                        "%s call RS485_read_data_s(0x%x, 4) error, retry..", func_name, addr);
                }
                Sleep(1);
//                DTXA_trace_t("TS", DTXA_TRACE_INT, func_name, "%s call RS485_read_data_s(0x%x, 4) error 0x%x, retry..", func_name, addr, rtn);
            }
            else if( OK == rtn )
            {
                break;
            }
        }
        // 重试失败后记录
        if( rtn != OK )
        {
            link_err[0] = rtn;
            link_err[1] = 0;
            rtn = MIO_RS485_READ_ERROR;
//            EEXA_log_error(rtn, link_err, __FILE__, __LINE__,
//                "%s call RS485_read_data_s(0x%x, 1) error", func_name, addr);
        }
        
    }
    
    if( OK == rtn )
    {
        var = (UINT32)buf[0] | (UINT32)buf[1] << 8 | (UINT32)buf[2] << 16  | (UINT32)buf[3] << 24;
        if( value != NULL )
        {
            *value = var;
        }
    }

    // 出口trace，需要人工检查修改
    DTXA_trace_t("TS", DTXA_TRACE_INT, func_name, "< (value = 0x%x) = 0x%x", var, rtn);
//its_udp_unlock();
    
	return rtn;
}


int MIO_write_reg
        (
        IN      int     addr,
        IN      UINT32  value
        )
{
	int rtn = OK;
    int i = 0;
    int index = 0;
    UINT8 buf[4] = { 0 };
    char *func_name = "MIO_write_reg";
    int link_err[2] = { 0 };

    // 入口trace，需要人工检查修改
    DTXA_trace_t("TS", DTXA_TRACE_INT, func_name, "> (addr = 0x%x value = 0x%x)", addr, value);

//its_udp_lock();

    if( OK == rtn )
    {
        buf[0] = (UINT8)(value & 0x000000ff);
        buf[1] = (UINT8)((value & 0x0000ff00) >> 8);
        buf[2] = (UINT8)((value & 0x00ff0000) >> 16);
        buf[3] = (UINT8)((value & 0xff000000) >> 24);
    }

    if( OK == rtn )
    {
        for( i = 0; i < 3; i++ )
        {
            rtn = network_write_data_s(addr, 4, buf);
            if( rtn != OK )
            {
                link_err[0] = rtn;
                link_err[1] = 0;
                rtn = MIO_RS485_WRITE_ERROR;
//                EEXA_log_error(rtn, link_err, __FILE__, __LINE__,
//                    "%s call RS485_write_data_s(0x%x, 4) error", func_name, addr);
                Sleep(1);
            }
            else if( OK == rtn )
            {
                break;
            }
        }
    }

    // 出口trace，需要人工检查修改
    DTXA_trace_t("WL", DTXA_TRACE_INT, func_name, "< () = 0x%x", rtn);

//    Sleep(1);
//its_udp_unlock();
    
	return rtn;
}


int MIO_read_reg_longs
        (
        IN      int     addr,
        OUT     UINT32  *value,
        IN      int     int32_size
        )
{
	int rtn = OK;
    int actlen = 0;
    int i = 0;
    int index = 0;
    int size = 0;
    char *func_name = "MIO_read_reg_longs";
    int link_err[2] = { 0 };
    unsigned char buf[1024] = { 0 };

    // 入口trace，需要人工检查修改
   DTXA_trace_t("TS", DTXA_TRACE_INT, func_name, "> (addr = 0x%x int32_size = %d)", addr, int32_size);

    // 参数检查
	if( ( int32_size > 256 ) || ( int32_size <= 0 ) )
    {
        // parameter error

        rtn = MIO_PARAMETER_ERROR;
    }

    if( value == NULL )
    {
        // parameter error
        rtn = MIO_PARAMETER_ERROR;
    }

    size = int32_size * 4;

//its_udp_lock();

    if( OK == rtn )
    {
        for( i = 0; i < 3; i++ )
        {
            rtn = network_read_data_s(addr, size, buf, &actlen);
            if( rtn != OK )
            {
                if( i > 0 )     // 超过1次错误后才记录错误
                {
                    link_err[0] = rtn;
                    link_err[1] = 0;
                    rtn = MIO_RS485_READ_ERROR;
//                    EEXA_log_error(rtn, link_err, __FILE__, __LINE__,
//                        "%s call RS485_read_data_s(0x%x, %d) error, retry..", func_name, addr, size);
                }
            }
            else if( OK == rtn )
            {
                break;
            }
        }
        if( rtn != OK )
        {
            link_err[0] = rtn;
            link_err[1] = 0;
            rtn = MIO_RS485_READ_ERROR;
//            EEXA_log_error(rtn, link_err, __FILE__, __LINE__,
//                "%s call RS485_read_data_s(0x%x, %d) error", func_name, addr, size);
        }
    }
    
    if( OK == rtn )
    {
        for( i = 0; i < int32_size; i++ )
        {
            index = i * 4;
            value[i] = (int)buf[index] | (int)buf[index + 1] << 8 | (int)buf[index + 2] << 16  | (int)buf[index + 3] << 24;
        }
    }
//its_udp_unlock();

    // 出口trace，需要人工检查修改
    DTXA_trace_t("TS", DTXA_TRACE_INT, func_name, "< () = 0x%x",  rtn);
    
	return rtn;
}


int MIO_write_reg_longs
        (
        IN      int     addr,
        IN      UINT32  *value,
        IN      int     int32_size
        )
{
	int rtn = OK;
    int i = 0;
    int index = 0;
    int size = 0;
    unsigned char buf[1024] = { 0 };
    char *func_name = "MIO_write_reg_longs";
    int link_err[2] = { 0 };

    // 入口trace，需要人工检查修改
    DTXA_trace_t("TS", DTXA_TRACE_INT, func_name, "> (addr = 0x%x int32_size = %d)", addr, int32_size);

    // 参数检查
	if( ( int32_size > 255 ) || ( int32_size <= 0 ) )
    {
        // parameter error
        rtn = MIO_PARAMETER_ERROR;
    }

//its_udp_lock();
    if( OK == rtn )
    {
        for( i = 0; i < int32_size; i++ )
        {
            buf[4*i + 0] = (UINT8)(value[i] & 0x000000ff);
            buf[4*i + 1] = (UINT8)((value[i] & 0x0000ff00) >> 8);
            buf[4*i + 2] = (UINT8)((value[i] & 0x00ff0000) >> 16);
            buf[4*i + 3] = (UINT8)((value[i] & 0xff000000) >> 24);
        }
    }

    size = int32_size * 4;

    if( OK == rtn )
    {
        for( i = 0; i < 3; i++ )
        {
            rtn = network_write_data_s(addr, size, buf);
            if( rtn != OK )
            {
                link_err[0] = rtn;
                link_err[1] = 0;
                rtn = MIO_RS485_WRITE_ERROR;
//                EEXA_log_error(rtn, link_err, __FILE__, __LINE__,
//                    "%s call RS485_write_data_s(0x%x, %d) error", func_name, addr, size);
            }
            else if( OK == rtn )
            {
                break;
            }
        }
    }

//its_udp_unlock();

    // 出口trace，需要人工检查修改
    DTXA_trace_t("TS", DTXA_TRACE_INT, func_name, "< () = 0x%x", rtn);
    
	return rtn;
}


// 读取一片寄存器空间内容, 16bit为单位
int MIO_read_reg_shorts(IN int addr, OUT UINT16 *value, IN int int16_size)
{
	int rtn = OK;
    int actlen = 0;
    int i = 0;
    int index = 0;
    int size = 0;
    char *func_name = "MIO_read_reg_longs";
    int link_err[2] = { 0 };
    unsigned char buf[1024] = { 0 };

    // 入口trace，需要人工检查修改
    DTXA_trace_t("TS", DTXA_TRACE_INT, func_name, "> (addr = 0x%x int16_size = %d)", addr, int16_size);

    // 参数检查
	if( ( int16_size > 500) || ( int16_size <= 0 ) )
    {
        // parameter error

        rtn = MIO_PARAMETER_ERROR;
    }

    if( value == NULL )
    {
        // parameter error
        rtn = MIO_PARAMETER_ERROR;
    }

    size = int16_size * 2;

its_udp_lock();

    if( OK == rtn )
    {
        for( i = 0; i < 3; i++ )
        {
            rtn = network_read_data_s(addr, size, buf, &actlen);
            if( rtn != OK )
            {
                if( i > 0 )     // 超过1次错误后才记录错误
                {
                    link_err[0] = rtn;
                    link_err[1] = 0;
                    rtn = MIO_RS485_READ_ERROR;
//                    EEXA_log_error(rtn, link_err, __FILE__, __LINE__,
//                        "%s call RS485_read_data_s(0x%x, %d) error, retry..", func_name, addr, size);
                }
            }
            else if( OK == rtn )
            {
                break;
            }
        }
        if( rtn != OK )
        {
            link_err[0] = rtn;
            link_err[1] = 0;
            rtn = MIO_RS485_READ_ERROR;
//            EEXA_log_error(rtn, link_err, __FILE__, __LINE__,
//                "%s call RS485_read_data_s(0x%x, %d) error", func_name, addr, size);
        }
    }
    
    if( OK == rtn )
    {
        for( i = 0; i < int16_size; i++ )
        {
            index = i * 2;
            value[i] = (UINT16)buf[index] | (UINT16)buf[index + 1] << 8;
        }
    }

its_udp_unlock();

    // 出口trace，需要人工检查修改
    DTXA_trace_t("TS", DTXA_TRACE_INT, func_name, "< () = 0x%x",  rtn);
    
	return rtn;
}



// 写入一片寄存器空间内容, 16bit为单位
int MIO_write_reg_shorts(IN int addr, IN UINT16 *value, IN int short_size)
{
	int rtn = OK;
    int i = 0;
    int index = 0;
    int size = 0;
    unsigned char buf[1024] = { 0 };


    // 参数检查
	if( ( short_size > 512 ) || ( short_size <= 0 ) )
    {
        // parameter error
        rtn = MIO_PARAMETER_ERROR;
    }

    if( OK == rtn )
    {
        for( i = 0; i < short_size; i++ )
        {
            buf[2*i + 0] = (UINT8)(value[i] & 0x00ff);
            buf[2*i + 1] = (UINT8)((value[i] & 0xff00) >> 8);
        }
    }

    size = short_size * 2;

its_udp_lock();

    if( OK == rtn )
    {
        for( i = 0; i < 3; i++ )
        {
            rtn = network_write_data_s(addr, size, buf);
            if( rtn != OK )
            {
//                link_err[0] = rtn;
//                link_err[1] = 0;
                rtn = MIO_RS485_WRITE_ERROR;
//                EEXA_log_error(rtn, link_err, __FILE__, __LINE__,
//                    "%s call RS485_write_data_s(0x%x, %d) error", func_name, addr, size);
            }
            else if( OK == rtn )
            {
                break;
            }
        }
    }
its_udp_unlock();


	return rtn;
}


// 只终止网络，调试用，关闭后可以使用mio调试助手就不冲突了
int MIO_terminate_network(void)
{
    int rtn = OK;

    rtn = network_terminate_s();

    return rtn;
}


// 单独初始化MIO的网络通信，使得可以访问MIO地址空间
int MIO_initialize_network(void)
{
    int rtn = OK;

//    system("start pingMIO.bat");    // 启动批处理，确保建立ARP表

    rtn = network_initialize_s();


    return rtn;
}


// 判断数值的某一个位是否为1
BOOL tsxa_is_bit_set(int value, int bit_index)
{
    BOOL rtn = 0;

    rtn = value & ( 0x1 << bit_index );

    return rtn;
}


// 设置sys_control的相应位为1
int TSAP_sys_control_set_bit
        (
        IN      int bit_index
        )
{
    int rtn = OK;
    int addr = 0;
    UINT32 value = 0;

    addr = SYS_CONTROL_ADDR;
    value |= (0x1 << bit_index);

    rtn = MIO_write_reg(addr, value);       

    return rtn;
}


// sys_control所有bit清零
int TSAP_sys_control_clr( void )
{
    int rtn = OK;
    int addr = 0;
    UINT32 value = 0;

    if( g_TSXA_auto_pos_err_reset )
    {
        value = 0x4000;     // bit14 : auto pos err reset
    }
    else
    {
        value = 0x0;
    }
    addr = SYS_CONTROL_ADDR;
    rtn = MIO_write_reg(addr, value);    
    
    return rtn;}


// mover control set bit 
int TSAP_mover_control_set_bit
        (
        IN      int id,
        IN      int bit_index
        )
{
    int rtn = OK;
    int addr = 0;
    UINT32 mover_control = 0x1;     // bit0: available 必须有效

    addr = MOVER_CONTROL_ADDR + id * 12;

    mover_control |= (0x1 << bit_index);

    rtn = MIO_write_reg(addr, mover_control);

    return rtn;
}


// mover control clr all
// mover control的控制位基本都是上升沿的, 全部清0即可，不用单独清理某位
int TSAP_mover_control_clr
        (
        IN      int id
        )
{
    int rtn = OK;
    int addr = 0;
    UINT32 mover_control = 0x1;     

    addr = MOVER_CONTROL_ADDR + id * 12;

    mover_control = 0x1;            // bit0: available 必须有效

    rtn = MIO_write_reg(addr, mover_control);

    return rtn;
}


int TSAP_sys_initialize( void )
{
    int rtn = OK;

    // bit0 : init
    rtn = TSAP_sys_control_set_bit(0);
    if( OK == rtn )
    {
        Sleep(NIOS_SLEEP_TIME);
        rtn = TSAP_sys_control_clr();
    }

    return rtn;
}


int TSAP_sys_terminate( void )
{
    int rtn = OK;

    // bit1 : term
    rtn = TSAP_sys_control_set_bit(1);
    if( OK == rtn )
    {
        Sleep(NIOS_SLEEP_TIME);
        rtn = TSAP_sys_control_clr();
    }

    return rtn;
}


int TSAP_sys_start_work( void )
{
    int rtn = OK;

    // bit2 : auto work EN
    rtn = TSAP_sys_control_set_bit(2);
    if( OK == rtn )
    {
        Sleep(NIOS_SLEEP_TIME);
        rtn = TSAP_sys_control_clr();
    }

    return rtn;
}


int TSAP_sys_stop_work( void )
{
    int rtn = OK;

    // bit3 : auto work OFF
    rtn = TSAP_sys_control_set_bit(3);
    if( OK == rtn )
    {
        Sleep(NIOS_SLEEP_TIME);
        rtn = TSAP_sys_control_clr();
    }
    
    return rtn;
}


int TSAP_sys_pause_work( void )
{
    int rtn = OK;

    // bit4: pause work
    rtn = TSAP_sys_control_set_bit(4);
    if( OK == rtn )
    {
        Sleep(NIOS_SLEEP_TIME);
        rtn = TSAP_sys_control_clr();
    }
    
    return rtn;
}


int TSAP_sys_resume_work( void )
{
    int rtn = OK;

    // bit5: resume work
    rtn = TSAP_sys_control_set_bit(5);
    if( OK == rtn )
    {
        Sleep(NIOS_SLEEP_TIME);
        rtn = TSAP_sys_control_clr();
    }
    
    return rtn;
}


int TSAP_sys_stop( void )
{
    int rtn = OK;
    
    // bit7: normal stop
    rtn = TSAP_sys_control_set_bit(7);
    if( OK == rtn )
    {
        Sleep(NIOS_SLEEP_TIME);
        rtn = TSAP_sys_control_clr();
    }
    
    return rtn;
}


int TSAP_sys_quick_stop( void )
{
    int rtn = OK;

    // bit8: quick stop 
    rtn = TSAP_sys_control_set_bit(8);
    if( OK == rtn )
    {
        Sleep(NIOS_SLEEP_TIME);
        rtn = TSAP_sys_control_clr();
    }

    return rtn;
}


int TSAP_sys_reset_err( void )
{
    int rtn = OK;

    // bit12: reset, clear all errors
    rtn = TSAP_sys_control_set_bit(12);
    if( OK == rtn )
    {
        Sleep(NIOS_SLEEP_TIME);
        rtn = TSAP_sys_control_clr();
    }
    
    return rtn;
}


int TSAP_sys_auto_pos_err_reset_on( void )
{
    int rtn = OK;

    // bit14: auto position error reset 电平有效
    if( OK == rtn )
    {
        rtn = TSAP_sys_control_set_bit(14);
        g_TSXA_auto_pos_err_reset = TRUE;
    }
    
    return rtn;
}


int TSAP_sys_auto_pos_err_reset_off( void )
{
    int rtn = OK;

    // bit14: auto position error reset 电平有效
    if( OK == rtn )
    {
        g_TSXA_auto_pos_err_reset = FALSE;
        rtn = TSAP_sys_control_clr();
    }
    
    return rtn;
}


int TSAP_sys_move_to_next_station_all( void )
{
    int rtn = OK;

    // bit15: move to next station
    rtn = TSAP_sys_control_set_bit(15);
    if( OK == rtn )
    {
        Sleep(NIOS_SLEEP_TIME);
        rtn = TSAP_sys_control_clr();
    }

    return rtn;
}


int TSAP_sys_enable_axis_all( void )
{
    int rtn = OK;

    // bit16: all mover servo on
    rtn = TSAP_sys_control_set_bit(16);
    if( OK == rtn )
    {
       Sleep(NIOS_SLEEP_TIME);
       rtn = TSAP_sys_control_clr();
    }

    return rtn;
}


int TSAP_sys_disable_axis_all( void )
{
    int rtn = OK;

    // bit17: all mover servo off
    rtn = TSAP_sys_control_set_bit(17);
    if( OK == rtn )
    {
        Sleep(NIOS_SLEEP_TIME);
        rtn = TSAP_sys_control_clr();
    }

    return rtn;
}


int TSAP_sys_load_default_mc( void )
{
    int rtn = OK;
    int addr = 0;
    UINT32 value = 0;

    // bit20-23: load default mc
    //      load默认机器常数,依次写3,B触发; 
    //      永久保存调整过的OP机器常数到Flash, 依次写5,A触发
    
    addr = SYS_CONTROL_ADDR;
    value = 0x300000;
    rtn = MIO_write_reg(addr, value);    

    Sleep(NIOS_SLEEP_TIME);

    if( OK == rtn )
    {
        value = 0xB00000;
        rtn = MIO_write_reg(addr, value);    
    }
    
    return rtn;}


int TSAP_sys_save_mc_to_flash( void )
{
    int rtn = OK;
    int addr = 0;
    UINT32 value = 0;

    // bit20-23: load default mc
    //      load默认机器常数,依次写3,B触发; 
    //      保存调整过的OP机器常数到Flash, 依次写5,A触发
    
    addr = SYS_CONTROL_ADDR;
    value = 0x500000;
    rtn = MIO_write_reg(addr, value);    

    Sleep(NIOS_SLEEP_TIME);

    if( OK == rtn )
    {
        value = 0xa00000;
        rtn = MIO_write_reg(addr, value);    
    }
    
    return rtn;}


int TSAP_sys_set_mover_offset
        (
        IN      int     axis,
        IN      double  offset
        )
{
    int rtn = OK;
    int addr = 0;
    UINT32 data = 0;
    UINT8   id = 0;
    UINT8   op = 0;
    INT16  set_offset = 0;
    
    BOOL save_to_flash = TRUE;

    addr = SYS_IN_MOVER_OFFSET_ADDR;
    
    id = (UINT8)axis;
    if( save_to_flash )
    {
        op = 0xf4;
    }
    else
    {
        op = 0x54;
    }
    set_offset = (INT16)(offset * 1000.0);      // mm -> um
    data = ( (UINT32)id << 24 ) | ( (UINT32)op << 16 ) | ( (UINT32)set_offset );

    // 写入数据，id, offset
    rtn = MIO_write_reg(addr, data); 
    
    Sleep(NIOS_SLEEP_TIME);

    // op更新
    if( save_to_flash )
    {
        op = 0xf5;
    }
    else
    {
        op = 0x55;
    }
    data = (UINT32)id << 24 | (UINT32)op << 16 | (UINT32)set_offset;
    rtn = MIO_write_reg(addr, data); 
    
    return rtn;}


int TSAP_sys_get_mover_offset
        (
        IN      int     axis,
        OUT      double  *offset
        )
{
    int rtn = OK;
    int addr = 0;
    UINT8 id = 0;
    INT16 pos_offset = 0;
    UINT32 data = 0;
    UINT32 value = 0;
    double var = 0.0;

    // 写入axis到0x43
    id = (UINT8)axis;
    data = (UINT32)id << 24;
    addr = 0x40;
    rtn = MIO_write_reg(addr, data);

    // 读取0x1040值
    if( OK == rtn )
    {
        addr = 0x1040;
        rtn = MIO_read_reg(addr, &value);
    }

    if( OK == rtn )
    {
        pos_offset = (INT16)( (UINT16)( value >> 16 ) );
        var = (double)(pos_offset) * 0.001;
    }

    if( offset != NULL )
    {
        *offset = var;
    }
    
    return rtn;}


int TSAP_sys_get_status
        (
        OUT     UINT32  *sys_status,
        OUT     UINT32  *sys_errno,
        OUT     UINT32 *sys_errinfo
        )
{
    int rtn = OK;
    int addr = 0;
    UINT32 value[2] = { 0 };
    int addr_errinfo = 0;
    UINT32 value_errinfo = 0;

#if 0
    addr = 0x1000;
    addr_errinfo = 0x102C;
    rtn = MIO_read_reg_longs(addr, value, 2);
    rtn = MIO_read_reg_longs(addr_errinfo, &value_errinfo, 1);
#endif
    value[0] = g_mio_sys_status_reg;
    value[1] = g_mio_sys_errno_reg;
    value_errinfo = g_mio_sys_errinfo_reg;

    if(  sys_status != NULL )
    {
        *sys_status = value[0];
    }

    
    if(  sys_errno != NULL )
    {
        *sys_errno = value[1];
    }

    if( sys_errinfo != NULL)
    {
        *sys_errinfo = value_errinfo;
    }

    rtn = g_TSAP_flush_sys_status_rtn;

    return rtn;        
}


int TSAP_sys_get_mover_num
        (
        OUT     int *mover_num,
        OUT     int *station_num
        )
{
    int rtn = OK;
    int addr = 0;
    UINT32 value = 0;
    int mover = 0;
    int station = 0;

    addr = 0x101c;
    rtn = MIO_read_reg(addr, &value);
    if( OK == rtn )
    {
        mover = (int)( ( value & 0xff00 ) >> 8 );
        station = (int)( value & 0xffff0000 >> 16 );
    }

    if(  mover_num != NULL )
    {
        *mover_num = mover;
    }
    
    if(  station_num != NULL )
    {
        *station_num = station;
    }

    return rtn;   
}


int TSAP_st_set_station_para
        (
        IN      int                             id,
        IN      TSXA_SYS_STATION_para_struct    para
        )
{
    int rtn = OK;
    int addr = 0;
    int size = 0;
    TSXA_SYS_STATION_OP_struct  data;
	BOOL save_to_flash = TRUE;

    if( id < 0 || id > 127)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    addr = SYS_IN_STATION_PARA_ADDR;

    if( save_to_flash )
    {
        data.station_op = 0xf4;
    }
    else
    {
        data.station_op = 0x54;
    }
    data.station_en = (UINT16)(para.station_en);
    data.station_id = (UINT8)id;
    data.allow_entering = (UINT16)para.allow_in;
    data.independent = (UINT16)para.independent;
    data.base_pos = (INT32)( para.base_pos * 1000 );     // mm -> um
    data.over_cycle_to_next = para.over_cycle_to_next;
    data.base_stop_sim_delay = ( para.stop_sim_delay );
    data.vel = (INT32)(para.vel);
    data.acc = (INT32)(para.acc);
    data.dec = (INT32)(para.dec);
    data.left_limit_enable = (UINT16)para.left_limit_en;
    data.right_limit_enable = (UINT16)para.right_limit_en;
    data.left = (INT16)para.left;
    data.right = (INT16)para.right;
    data.next_station_id = (UINT32)para.next_id;
    
    size = sizeof(TSXA_SYS_STATION_OP_struct) / 4;

    // 写入数据
    rtn = MIO_write_reg_longs(addr, (UINT32 *)&data, size); 
    
    Sleep(NIOS_SLEEP_TIME);

    // op更新
    if( save_to_flash )
    {
        data.station_op = 0xf5;
    }
    else
    {
        data.station_op = 0x55;
    }
    rtn = MIO_write_reg_longs(addr, (UINT32 *)&data, size); 
    
    return rtn;
}


int TSAP_st_move_next_station
        (
        IN      int station
        )
{
    int rtn = OK;
    int addr = 0;
    UINT32 value = 0;
    int id = 0;

    if( station < 0 || station > 63)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    if( station > 31 )
    {
        id = station - 32;
        addr = STN_MOVE_NEXT_32_ADDR;
    }
    else
    {
        id = station;
        addr = STN_MOVE_NEXT_0_ADDR;
    }
    value |= (0x1 << id);
    
    rtn = MIO_write_reg(addr, value);       
    if( OK == rtn )
    {
        Sleep(FPGA_SLEEP_TIME);
        MIO_write_reg(addr, 0x0);       // clear bits
    }

    return rtn;
}


int TSAP_st_move_next_station_multi
        (
        IN      UINT32  station_list,
        IN      UINT32  station_list_32_63
        )
{
    int rtn = OK;
    int addr = 0;
    UINT32 value = 0;

    addr = 0x80;
    value = station_list;
    rtn = MIO_write_reg(addr, value);  
    if( OK == rtn )
    {
        addr = 0x88;
        value = station_list_32_63;
        rtn = MIO_write_reg(addr, value);       
    }

    Sleep(FPGA_SLEEP_TIME);

    if( OK == rtn )
    {
        addr = 0x80;
        MIO_write_reg(addr, 0x0);       // clear bits

        addr = 0x88;
        MIO_write_reg(addr, 0x0);       // clear bits
    }

    return rtn;
}


int TSAP_st_qstop
        (
        IN      int station
        )
{
    int rtn = OK;
    int addr = 0;
    UINT32 value = 0;
    int id = 0;

    if( station < 0 || station > 63)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    if( station > 31 )
    {
        id = station - 32;
        addr = STN_QSTOP_32_ADDR;
    }
    else
    {
        id = station;
        addr = STN_QSTOP_0_ADDR;
    }
    value |= (0x1 << id);
    
    rtn = MIO_write_reg(addr, value);       
    if( OK == rtn )
    {
        Sleep(FPGA_SLEEP_TIME);
        MIO_write_reg(addr, 0x0);       // clear bits
    }

    return rtn;
}


int TSAP_st_qstop_resume
        (
        IN      int station
        )
{
    int rtn = OK;
    int addr = 0;
    UINT32 value = 0;
    int id = 0;

    if( station < 0 || station > 63)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    if( station > 31 )
    {
        id = station - 32;
        addr = STN_QSTOP_RESUME_32_ADDR;
    }
    else
    {
        id = station;
        addr = STN_QSTOP_RESUME_0_ADDR;
    }
    value |= (0x1 << id);
    
    rtn = MIO_write_reg(addr, value);       
    if( OK == rtn )
    {
        Sleep(FPGA_SLEEP_TIME);
        MIO_write_reg(addr, 0x0);       // clear bits
    }

    return rtn;
}


int TSAP_st_enable
        (
        IN      int station_id
        )
{
    int rtn = OK;
    int addr = 0;
    UINT32 value = 0;
    UINT32 st_value = 0;
    int id = 0;
    char *func_name = "TSAP_st_enable";
    
    // 入口trace，需要人工检查修改
    DTXA_trace_t("TS", DTXA_TRACE_INT, func_name, "> (station_id = %d )", station_id);


    if( station_id < 0 || station_id > 63)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

#if 0
//  直接操作station_op
    addr = 0x44;
    value = ( (UINT32)( (UINT8)station_id ) << 24 ) | ( 0x20 << 16);   // op bit5 上升沿
    MIO_write_reg(addr, value);  

    if( OK == rtn )
    {
        Sleep(FPGA_SLEEP_TIME);
        MIO_write_reg(addr, 0x0);       // clear bits
    }
    Sleep(10);
#endif

    // station_control  0x7c00 - 0x7cff  上升沿触发  bit0: stn_en   bit1: stn_dis bit2: stn_allow_en  bit3: stn_allow_dis
    addr = 0x7c00 + station_id * 4;
    MIO_write_reg(addr, 0x0);
    Sleep(FPGA_SLEEP_TIME);
    MIO_write_reg(addr, 0x1);


    // 出口trace，需要人工检查修改
    DTXA_trace_t("TS", DTXA_TRACE_INT, func_name, "< () = 0x%x", rtn);


    return rtn;
}


int TSAP_st_disable
        (
        IN      int station_id
        )
{
    int rtn = OK;
    int addr = 0;
    UINT32 value = 0;
    UINT32 st_value = 0;
    int id = 0;
    char *func_name = "TSAP_st_disable";

    // 入口trace，需要人工检查修改
    DTXA_trace_t("TS", DTXA_TRACE_INT, func_name, "> (station_id = %d )", station_id);


    if( station_id < 0 || station_id > 63)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

#if 0
//  直接操作station_op
    addr = 0x44;
    value = ( (UINT32)( (UINT8)station_id ) << 24 ) | ( 0x80 << 16);   // op bit7 上升沿
    MIO_write_reg(addr, value);  

    if( OK == rtn )
    {
        Sleep(FPGA_SLEEP_TIME);
        MIO_write_reg(addr, 0x0);       // clear bits
    }

    Sleep(10);
#endif

    // station_control  0x7c00 - 0x7cff  上升沿触发  bit0: stn_en   bit1: stn_dis bit2: stn_allow_en  bit3: stn_allow_dis
    addr = 0x7c00 + station_id * 4;
    MIO_write_reg(addr, 0x0);
    Sleep(FPGA_SLEEP_TIME);
    MIO_write_reg(addr, 0x2);

    // 出口trace，需要人工检查修改
    DTXA_trace_t("TS", DTXA_TRACE_INT, func_name, "< () = 0x%x", rtn);

    return rtn;
}


int TSAP_st_get_mover_id
        (
        IN      int     st_id,
        OUT     BOOL    *reached,
        OUT     int     *mover_id
        )
{
    int rtn = 0;
    int axis = 0;
    int stn_reached_index = 0;
    int stn_id_offset_index = 0;
    UINT32 value = 0;
    int addr = 0;
    int move_bits = 0;
    BOOL mover_reached = FALSE;

	if( st_id < 0 || st_id > 63)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }
    
//its_udp_lock();

#if 0
    // 先获取当前工位上的动子id
    stn_reached_index = st_id / 4;
    stn_id_offset_index =  st_id % 4;
    addr = 0x10c0 + stn_reached_index * 4;

    rtn = MIO_read_reg(addr, &value);
    if( OK == rtn )
    {
        // 获取id
        move_bits = stn_id_offset_index * 8;
        axis = (int)( ( value & (0xff << move_bits ) ) >> move_bits );
    }
#endif
    axis = (int)( (UINT32)g_mio_stn_status_reg.stn_reached_axis_id[st_id] );

    if( OK == rtn )
    {
        if( axis == 0xFC )
        {
            mover_reached = FALSE;
        }
        else if( ( axis < 108) || ( axis == 0xff ) )
        {
             mover_reached = TRUE;
        }

        if( reached != NULL )
        {
            *reached = mover_reached;
        }
        
        if( mover_id != NULL )
        {
            *mover_id = axis;
        }

        rtn = g_TSAP_flush_stn_status;

    }


//its_udp_unlock();
    return rtn;
}


int TSAP_axis_enable
        (
        IN      int axis
        )
{
    int rtn = OK;

    if( axis < 0 || axis > 127)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    // bit1: servo on
    rtn = TSAP_mover_control_set_bit(axis, 1); 
    if( OK == rtn )
    {
         Sleep(FPGA_SLEEP_TIME);
         rtn = TSAP_mover_control_clr(axis);
    }

    return rtn;
}


int TSAP_axis_disable
        (
        IN      int axis
        )
{
    int rtn = OK;

    if( axis < 0 || axis > 127)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    // bit2: servo off
    rtn = TSAP_mover_control_set_bit(axis, 2); 
    if( OK == rtn )
    {
        Sleep(FPGA_SLEEP_TIME);
        rtn = TSAP_mover_control_clr(axis);
    }

    return rtn;
}


int TSAP_axis_move_abs
        (
        IN      int     axis,
        IN      double  pos,
        IN      double  vel,
        IN      double  acc,
        IN      double  dec
        )
{
    int rtn = OK;
    int addr = 0;
    UINT16 control = 0x1;
    UINT16 target_vel = 0;
    UINT16 target_acc = 0;
    UINT16 target_dec = 0;
    int  target_pos = 0;
    double error = 0.1;

    UINT16 all_data[6] = { 0 };
    
    if( axis < 0 || axis > 127)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    
    target_vel = (UINT16)vel;
    if( pos >= 0.0 )
    {
        error = 0.1;
    }
    else
    {
        error = -0.1;
    }
    target_pos = (int)(pos * 1000 + error);     // mm->um
    target_acc = (UINT16)acc;
    target_dec = (UINT16)dec;

    control = 0x1;
    // 数据填充
    all_data[0] = control;      
    all_data[1] = target_vel;
    all_data[2] = (UINT16)(target_pos & 0xffff);
    all_data[3] = (UINT16)( ( target_pos & 0xffff0000 ) >> 16);
    all_data[4] = target_acc;
    all_data[5] = target_dec;

    // clear control, set parameter
    addr = MOVER_CONTROL_ADDR + axis * 12;
//    rtn = MIO_write_reg_shorts(addr, all_data, 6);
    rtn = MIO_write_reg_longs(addr, (UINT32 *)all_data, 3);

    // control bit3: move abs
    if( OK == rtn )
    {
        control = 0x9;
        all_data[0] = control;      
        rtn = MIO_write_reg_longs(addr, (UINT32 *)all_data, 2);
    }
    
    if( OK == rtn )
    {
        // delay
        Sleep(FPGA_SLEEP_TIME);
        TSAP_mover_control_clr(axis);   // clear mover control
    }

    return rtn;
}


int TSAP_axis_limit_move_abs
        (
        IN      int     axis,
        IN      double  pos,
        IN      double  max_offset,
        IN      double  vel
        )
{
    int rtn = OK;
    int addr = 0;
    UINT16 control = 0x1;
    UINT16 target_vel = 0;
    UINT16 target_acc = 0;
    UINT16 target_dec = 0;
    int  target_pos = 0;
    double error = 0.1;
    double cur_pos = 0.0;
    double cur_vel = 0.0;
    

    UINT16 all_data[6] = { 0 };
    
    if( axis < 0 || axis > 127)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    // 先获取当前位置
    rtn = TSAP_get_mover_pos(axis, &cur_pos, &cur_vel);
    if( OK == rtn )
    {
        if( fabs(cur_pos - pos) > max_offset )
        {
            rtn = TSXA_PARAMETER_ERROR;
        }
    }

    if( OK == rtn )
    {
        target_vel = (UINT16)vel;
        if( pos >= 0.0 )
        {
            error = 0.1;
        }
        else
        {
            error = -0.1;
        }
        target_pos = (int)(pos * 1000 + error);     // mm->um
        target_acc = (UINT16)0;
        target_dec = (UINT16)0;

        control = 0x1;
        // 数据填充
        all_data[0] = control;      
        all_data[1] = target_vel;
        all_data[2] = (UINT16)(target_pos & 0xffff);
        all_data[3] = (UINT16)( ( target_pos & 0xffff0000 ) >> 16);
        all_data[4] = target_acc;
        all_data[5] = target_dec;

        // clear control, set parameter
        addr = MOVER_CONTROL_ADDR + axis * 12;
    //    rtn = MIO_write_reg_shorts(addr, all_data, 6);
        rtn = MIO_write_reg_longs(addr, (UINT32 *)all_data, 3);
    }

    // control bit3: move abs
    if( OK == rtn )
    {
        control = 0x9;
        all_data[0] = control;      
        rtn = MIO_write_reg_longs(addr, (UINT32 *)all_data, 2);
    }
    
    if( OK == rtn )
    {
        // delay
        Sleep(FPGA_SLEEP_TIME);
        TSAP_mover_control_clr(axis);   // clear mover control
    }
    return rtn;
}


int TSAP_axis_move_rel
        (
        IN      int     axis,
        IN      double  pos,
        IN      double  vel,
        IN      double  acc,
        IN      double  dec
        )
{
    int rtn = OK;
    int addr = 0;
    UINT16 control = 0x1;
    UINT16 target_vel = 0;
    UINT16 target_acc = 0;
    UINT16 target_dec = 0;
    int  target_pos = 0;
    double error = 0.1;


// for debug frank
//printf("TSXA_axis_move_rel(): axis: %d pos:%f\n", axis, pos);

    UINT16 all_data[6] = { 0 };

    if( axis < 0 || axis > 127)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }
    
    target_vel = (UINT16)vel;
    if( pos >= 0.0 )
    {
        error = 0.1;
    }
    else
    {
        error = -0.1;
    }
    target_pos = (int)(pos * 1000 + error);     // mm->um
    target_acc = (UINT16)acc;
    target_dec = (UINT16)dec;

    control = 0x1;
    // 数据填充
    all_data[0] = control;      
    all_data[1] = target_vel;
    all_data[2] = (UINT16)(target_pos & 0xffff);
    all_data[3] = (UINT16)( ( target_pos & 0xffff0000 ) >> 16);
    all_data[4] = target_acc;
    all_data[5] = target_dec;

    // clear control, set parameter
    addr = MOVER_CONTROL_ADDR + axis * 12;
//    rtn = MIO_write_reg_shorts(addr, all_data, 6);
    rtn = MIO_write_reg_longs(addr, (UINT32 *)all_data, 3);

    // control bit4: move rel
    if( OK == rtn )
    {
        rtn = TSAP_mover_control_set_bit(axis, 4);
    }

    if( OK == rtn )
    {
        Sleep(FPGA_SLEEP_TIME);
        TSAP_mover_control_clr(axis); 
    }
    return rtn;
}


int TSAP_axis_quick_stop
        (
        IN      int axis
        )
{
    int rtn = OK;

    if( axis < 0 || axis > 127)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    // bit7: quick stop
    if( OK == rtn )
    {
        rtn = TSAP_mover_control_set_bit(axis, 7);      
    }
    if( OK == rtn )
    {
        Sleep(FPGA_SLEEP_TIME);
        rtn = TSAP_mover_control_clr(axis);
    }


    return rtn;
}


int TSAP_axis_stop
        (
        IN      int axis
        )
{
    int rtn = OK;

    if( axis < 0 || axis > 127)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    // bit8: stop
    rtn = TSAP_mover_control_set_bit(axis, 8);
    if( OK == rtn )
    {
        Sleep(FPGA_SLEEP_TIME);
        rtn = TSAP_mover_control_clr(axis);
    }

    return rtn;
}


int TSAP_axis_reset
        (
        IN      int axis
        )
{
    int rtn = OK;

    if( axis < 0 || axis > 127)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    // bit9: reset
    rtn = TSAP_mover_control_set_bit(axis, 9);  
    if( OK == rtn )
    {
        Sleep(FPGA_SLEEP_TIME);
        rtn = TSAP_mover_control_clr(axis);
    }

    return rtn;
}


int TSAP_axis_move_vel
        (
        IN      int     axis,
        IN      BOOL    forward,
        IN      double  vel,
        IN      double  acc
        )
{
    int rtn = OK;
    int addr = 0;
    UINT16 control = 0x1;
    UINT16 target_vel = 0;
    UINT16 target_acc = 0;
    UINT16 target_dec = 0;
    int  target_pos = 0;
    double error = 0.1;

    UINT16 all_data[6] = { 0 };

    if( axis < 0 || axis > 127)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    
    target_vel = (UINT16)vel;
    if( forward )
    {
        target_pos = 100;
    }
    else
    {
        target_pos = -100;
    }
    target_acc = (UINT16)acc;
    target_dec = (UINT16)acc;

    control = 0x1;
    // 数据填充
    all_data[0] = control;      
    all_data[1] = target_vel;
    all_data[2] = (UINT16)(target_pos & 0xffff);
    all_data[3] = (UINT16)( ( target_pos & 0xffff0000 ) >> 16);
    all_data[4] = target_acc;
    all_data[5] = target_dec;

    // clear control, set parameter
    addr = MOVER_CONTROL_ADDR + axis * 12;
//    rtn = MIO_write_reg_shorts(addr, all_data, 6);
    rtn = MIO_write_reg_longs(addr, (UINT32 *)all_data, 3);

    // bit10: move vel
    if( OK == rtn )
    {
        rtn = TSAP_mover_control_set_bit(axis, 10);  
    }

    if( OK == rtn )
    {
        // delay
        Sleep(FPGA_SLEEP_TIME);
        rtn = TSAP_mover_control_clr(axis);
    }

    return rtn;
}


int TSAP_axis_change_vel
        (
        IN      int     axis,
        IN      double  vel
        )
{
    int rtn = OK;
    int addr = 0;
    UINT16 target_vel = 0;
    UINT32 control = 0;

    if( axis < 0 || axis > 127)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    // set vel and control
    if( OK == rtn )
    {
        target_vel = (UINT16)( vel + 0.1);
        control = 0x00000801 | ( (UINT32)(target_vel) << 16 );   // bit0 bit11
        addr = MOVER_TARGET_VEL_ADDR + axis * 12;
        rtn = MIO_write_reg(addr, control);
    }

    if( OK == rtn )
    {
        Sleep(FPGA_SLEEP_TIME);
        rtn = TSAP_mover_control_clr(axis);
    }
    return rtn;
}


int TSAP_axis_move_abs_g
        (
        IN      int     num,
        IN      int     *axis_list,
        IN      double  *pos_list,
        IN      double  *vel_list,
        IN      double  *acc_list,
        IN      double  *dec_list
        )
{
    int rtn = OK;
    int id_max = 0;
    int id_min = 0;
    int axis = 0;
    int target_pos = 0;
    UINT16 target_vel = 0;
    UINT16 target_acc = 0;
    UINT16 target_dec = 0;
    UINT16 control = 0;
    int i = 0;
    int mover_num = 0;
    int addr = 0;
    int size = 0;
    int id = 0;
    TSXA_MOVER_INPUT_struct mover[128] = { 0 };

    if( num < 0 || num > 127)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    // 统计动子id最大值和最小值
    for( i = 0; i < num; i++ )
    {
        axis = axis_list[i];
        if( axis > id_max )
        {
            id_max = axis;
        }
        if( axis < id_min )
        {
            id_min = axis;
        }
    }
    mover_num = id_max - id_min + 1;

    // 获取所有id_min到id_max动子的数据
    addr = MOVER_CONTROL_ADDR + sizeof(TSXA_MOVER_INPUT_struct) * id_min;   // 动子id_min开始
    size = sizeof(TSXA_MOVER_INPUT_struct) * mover_num;
    rtn = MIO_read_reg_shorts(addr, (UINT16 *)mover, size / 2);

    // 参数填入
    if( OK == rtn )
    {
        for( i = 0; i < num; i++ )
        {
            axis = axis_list[i];        // 动子id
            id = axis - id_min;         // mover[id], 0对应id_min
            mover[id].control = 0x1;        // clear control bit
            mover[id].target_pos = (int)(pos_list[i] * 1000.0);     // mm -> um
            if( vel_list[i] > 0.1 )
            {
                mover[id].target_vel = (UINT16)(vel_list[i] + 0.1);
            }
            if( acc_list[i] > 0.1 )
            {
                mover[id].target_acc = (UINT16)(acc_list[i] + 0.1);
            }
            if( dec_list[i] > 0.1 )
            {
                mover[id].target_dec = (UINT16)(dec_list[i] + 0.1);
            }
        }
    }

    // 一起写入数据, clear control, set parameter
    if( OK == rtn )
    {
        if( mover_num > 82 )    // 分2次发送
        {
            size = sizeof(TSXA_MOVER_INPUT_struct) * 82 / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size);

            addr = MOVER_CONTROL_ADDR + sizeof(TSXA_MOVER_INPUT_struct) * (82 + id_min);
            size = sizeof(TSXA_MOVER_INPUT_struct) * (mover_num - 82) / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)&mover[82].control, size);
        }
        else
        {
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size / 2);
        }
    }

    // delay
    Sleep(FPGA_SLEEP_TIME);

    // 一起写入数据, control bit3: move abs
    if( OK == rtn )
    {
        for( i = 0; i < num; i++ )
        {
            axis = axis_list[i];        // 动子id
            id = axis - id_min;         // mover[id], 0对应id_min
            mover[id].control = 0x9;        // bit0, bit3
        }

        if( mover_num > 82 )    // 分2次发送
        {
            size = sizeof(TSXA_MOVER_INPUT_struct) * 82 / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size);

            addr = MOVER_CONTROL_ADDR + sizeof(TSXA_MOVER_INPUT_struct) * (82 + id_min);
            size = sizeof(TSXA_MOVER_INPUT_struct) * (mover_num - 82) / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)&mover[82].control, size);
        }
        else
        {
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size / 2);
        }
    }


    // 一起写入数据, clear bit3
    if( OK == rtn )
    {
        Sleep(FPGA_SLEEP_TIME);

        for( i = 0; i < num; i++ )
        {
            axis = axis_list[i];        // 动子id
            id = axis - id_min;         // mover[id], 0对应id_min
            mover[id].control = 0x1;        // bit0,  clear bit3
        }

        if( mover_num > 82 )    // 分2次发送
        {
            size = sizeof(TSXA_MOVER_INPUT_struct) * 82 / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size);

            addr = MOVER_CONTROL_ADDR + sizeof(TSXA_MOVER_INPUT_struct) * (82 + id_min);
            size = sizeof(TSXA_MOVER_INPUT_struct) * (mover_num - 82) / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)&mover[82].control, size);
        }
        else
        {
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size / 2);
        }
    }
    return rtn;
}


int TSAP_axis_move_rel_g
        (
        IN      int     num,
        IN      int     *axis_list,
        IN      double  *pos_list,
        IN      double  *vel_list,
        IN      double  *acc_list,
        IN      double  *dec_list
        )
{
    int rtn = OK;
    int id_max = 0;
    int id_min = 0;
    int axis = 0;
    int target_pos = 0;
    UINT16 target_vel = 0;
    UINT16 target_acc = 0;
    UINT16 target_dec = 0;
    UINT16 control = 0;
    int i = 0;
    int mover_num = 0;
    int addr = 0;
    int size = 0;
    int id = 0;
    TSXA_MOVER_INPUT_struct mover[128] = { 0 };

    if( num < 0 || num > 127)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    // 统计动子id最大值和最小值
    for( i = 0; i < num; i++ )
    {
        axis = axis_list[i];
        if( axis > id_max )
        {
            id_max = axis;
        }
        if( axis < id_min )
        {
            id_min = axis;
        }
    }
    mover_num = id_max - id_min + 1;

    // 获取所有id_min到id_max动子的数据
    addr = MOVER_CONTROL_ADDR + sizeof(TSXA_MOVER_INPUT_struct) * id_min;   // 动子id_min开始
    size = sizeof(TSXA_MOVER_INPUT_struct) * mover_num;
    rtn = MIO_read_reg_shorts(addr, (UINT16 *)mover, size / 2);

    // 参数填入
    if( OK == rtn )
    {
        for( i = 0; i < num; i++ )
        {
            axis = axis_list[i];        // 动子id
            id = axis - id_min;         // mover[id], 0对应id_min
            mover[id].control = 0x1;        // clear control bit
            mover[id].target_pos = (int)(pos_list[i] * 1000.0);     // mm -> um
            if( vel_list[i] > 0.1 )
            {
                mover[id].target_vel = (UINT16)(vel_list[i] + 0.1);
            }
            if( acc_list[i] > 0.1 )
            {
                mover[id].target_acc = (UINT16)(acc_list[i] + 0.1);
            }
            if( dec_list[i] > 0.1 )
            {
                mover[id].target_dec = (UINT16)(dec_list[i] + 0.1);
            }
        }
    }

    // 一起写入数据, clear control, set parameter
    if( OK == rtn )
    {
        if( mover_num > 82 )    // 分2次发送
        {
            size = sizeof(TSXA_MOVER_INPUT_struct) * 82 / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size);

            addr = MOVER_CONTROL_ADDR + sizeof(TSXA_MOVER_INPUT_struct) * (82 + id_min);
            size = sizeof(TSXA_MOVER_INPUT_struct) * (mover_num - 82) / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)&mover[82].control, size);
        }
        else
        {
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size / 2);
        }
    }

    // delay
    Sleep(FPGA_SLEEP_TIME);

    // 一起写入数据, control bit3: move abs
    if( OK == rtn )
    {
        for( i = 0; i < num; i++ )
        {
            axis = axis_list[i];        // 动子id
            id = axis - id_min;         // mover[id], 0对应id_min
            mover[id].control = 0x11;        // bit0, bit4
        }

        if( mover_num > 82 )    // 分2次发送
        {
            size = sizeof(TSXA_MOVER_INPUT_struct) * 82 / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size);

            addr = MOVER_CONTROL_ADDR + sizeof(TSXA_MOVER_INPUT_struct) * (82 + id_min);
            size = sizeof(TSXA_MOVER_INPUT_struct) * (mover_num - 82) / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)&mover[82].control, size);
        }
        else
        {
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size / 2);
        }
    }


    // 一起写入数据, clear bit4
    if( OK == rtn )
    {
        Sleep(FPGA_SLEEP_TIME);

        for( i = 0; i < num; i++ )
        {
            axis = axis_list[i];        // 动子id
            id = axis - id_min;         // mover[id], 0对应id_min
            mover[id].control = 0x1;        // bit0,  clear bit4
        }

        if( mover_num > 82 )    // 分2次发送
        {
            size = sizeof(TSXA_MOVER_INPUT_struct) * 82 / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size);

            addr = MOVER_CONTROL_ADDR + sizeof(TSXA_MOVER_INPUT_struct) * (82 + id_min);
            size = sizeof(TSXA_MOVER_INPUT_struct) * (mover_num - 82) / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)&mover[82].control, size);
        }
        else
        {
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size / 2);
        }
    }
    return rtn;
}


int TSAP_axis_move_rel_all
        (
        IN      int     num,
        IN      double  pos_rel,
        IN      double  vel,
        IN      double  acc,
        IN      double  dec
        )
{
    int rtn = OK;
    int target_pos = 0;
    UINT16 target_vel = 0;
    UINT16 target_acc = 0;
    UINT16 target_dec = 0;
    UINT16 control = 0;
    int i = 0;
    int addr = 0;
    int size = 0;
    TSXA_MOVER_INPUT_struct mover[128] = { 0 };

    if( num < 0 || num > 127)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }


    // 获取所有动子的数据
    addr = MOVER_CONTROL_ADDR ;   // 动子从0开始
    size = sizeof(TSXA_MOVER_INPUT_struct) * num;
    rtn = MIO_read_reg_shorts(addr, (UINT16 *)mover, size / 2);

    // 参数填入
    if( OK == rtn )
    {
        for( i = 0; i < num; i++ )
        {
            mover[i].control = 0x1;        // clear control bit
            mover[i].target_pos = (int)(pos_rel * 1000.0);     // mm -> um
            if( vel > 0.1 )
            {
                mover[i].target_vel = (UINT16)(vel + 0.1);
            }
            if( acc > 0.1 )
            {
                mover[i].target_acc = (UINT16)(acc + 0.1);
            }
            if( dec > 0.1 )
            {
                mover[i].target_dec = (UINT16)(dec + 0.1);
            }
        }
    }

    // 一起写入数据, clear control, set parameter
    if( OK == rtn )
    {
        if( num > 82 )    // 分2次发送
        {
            size = sizeof(TSXA_MOVER_INPUT_struct) * 82 / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size);

            addr = MOVER_CONTROL_ADDR + sizeof(TSXA_MOVER_INPUT_struct) * 82;
            size = sizeof(TSXA_MOVER_INPUT_struct) * (num - 82) / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)&mover[82].control, size);
        }
        else
        {
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size / 2);
        }
    }

    // delay
    Sleep(FPGA_SLEEP_TIME);

    // 一起写入数据, control bit4: move rel
    if( OK == rtn )
    {
        for( i = 0; i < num; i++ )
        {
            mover[i].control = 0x11;        // bit0, bit4
        }

        if( num > 82 )    // 分2次发送
        {
            size = sizeof(TSXA_MOVER_INPUT_struct) * 82 / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size);

            addr = MOVER_CONTROL_ADDR + sizeof(TSXA_MOVER_INPUT_struct) * 82;
            size = sizeof(TSXA_MOVER_INPUT_struct) * (num - 82) / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)&mover[82].control, size);
        }
        else
        {
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size / 2);
        }
    }


    // 一起写入数据, clear bit4
    if( OK == rtn )
    {
        for( i = 0; i < num; i++ )
        {
            mover[i].control = 0x1;        // bit0, clear bit4
        }

        if( num > 82 )    // 分2次发送
        {
            size = sizeof(TSXA_MOVER_INPUT_struct) * 82 / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size);

            addr = MOVER_CONTROL_ADDR + sizeof(TSXA_MOVER_INPUT_struct) * 82;
            size = sizeof(TSXA_MOVER_INPUT_struct) * (num - 82) / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)&mover[82].control, size);
        }
        else
        {
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size / 2);
        }
    }
    return rtn;
}


int TSAP_axis_get_status
        (
        IN      int     axis,
        OUT     UINT16  *mover_status,
        OUT     double  *act_pos,
        OUT     double  *act_vel
        )
{
    int rtn = OK;
    int addr = 0;
    int size = 0;
    TSXA_MOVER_OUTPUT_struct  mover;

    if( axis < 0 || axis > 127)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    addr = MOVER_STATUS_ADDR + axis * 8;
    size = sizeof(TSXA_MOVER_OUTPUT_struct) / 2;
    rtn = MIO_read_reg_shorts(addr, (UINT16 *)&mover, size);

    if( mover_status != NULL )
    {
        *mover_status = mover.status;
    }
    
    if( act_vel != NULL )
    {
        *act_vel = (double)mover.act_vel;
    }

    if( act_pos != NULL )
    {
        *act_pos = (double)mover.act_pos * 0.001;
    }
    return rtn;
}


int TSAP_axis_get_status_g
        (
        IN      int     mover_num,
        IN      int     *axis_list,
        OUT     UINT16  *mover_status_list,
        OUT     double  *act_vel_list,
        OUT     double  *act_pos_list
        )
{
    int rtn = OK;
    int addr = 0;
    int size = 0;
    int i = 0;
    int axis = 0;
    int id = 0;
    int id_min = 0;
    int id_max = 0;
    int num = 0;
    TSXA_MOVER_OUTPUT_struct  mover[128] = { 0 };

    if( mover_num < 0 || mover_num > 127)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    // 统计动子id最大值和最小值
    for( i = 0; i < mover_num; i++ )
    {
        axis = axis_list[i];
        if( axis > id_max )
        {
            id_max = axis;
        }
        if( axis < id_min )
        {
            id_min = axis;
        }
    }
    num = id_max - id_min + 1;

    addr = MOVER_STATUS_ADDR + id_min * 8;
    size = sizeof(TSXA_MOVER_OUTPUT_struct) * num / 2;
    rtn = MIO_read_reg_shorts(addr, (UINT16 *)&mover, size);    // 124个动子以下可以一次读取

    if( OK == rtn )
    {
        for( i = 0; i < mover_num; i++ )
        {
            axis = axis_list[i];
            id = axis - id_min;         // mover[id], 0对应id_min
            

            if( mover_status_list != NULL )
            {
                mover_status_list[i] = mover[id].status;
            }
            
            if( act_vel_list != NULL )
            {
                act_vel_list[i] = (double)mover[id].act_vel;
            }

            if( act_pos_list != NULL )
            {
                act_pos_list[i] = (double)mover[id].act_pos * 0.001;
            }
        }
    }
    return rtn;
}


int TSAP_axis_wait_move_end
        (
        IN      int axis,
        IN      int timeout
        )
{
    int rtn = OK;
    BOOL stopped = FALSE;
    UINT16 status = 0;
    UINT32 tick1 = 0;
    UINT32 tick2 = 0;
    int tick = 0;
    int tick_num = 0;

    if( axis < 0 || axis > 127)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    if( timeout < 0 )
    {
        tick_num = 0x7fffffff;          // 永远, 取个很大的值
    }
    else
    {
        tick_num = timeout;
    }
    
    tick1 = GetTickCount();

    for( ;; )
    {
        // 获取动子状态信息
        rtn = TSAP_axis_get_status(axis, &status, NULL, NULL);
        
        // 判断是否停止
        if( OK == rtn )
        {
            if( !tsxa_is_bit_set(status, 2) )        // bit2: moving
            {
                stopped = TRUE;
                break;
            }
        }
        
        tick2 = GetTickCount();
        // 防止tick数值32bit溢出
        tick = (int)tick2 - (int)tick1;
        if( abs( tick ) >= tick_num )
        {
            rtn = TSXA_TIMEOUT_ERROR;
            break;
        }
        
        Sleep(2);
    }
    return rtn;
}


int TSAP_axis_wait_move_end_g
        (
        IN      int num,
        IN      int *axis_list,
        IN      int timeout
        )
{
    int rtn = OK;
    BOOL stopped = FALSE;
    UINT16 status[128] = { 0 };
    UINT32 tick1 = 0;
    UINT32 tick2 = 0;
    int tick = 0;
    int tick_num = 0;
    int i = 0;
    BOOL stop_list[128] = { 0 };
    
    if( num < 0 || num > 127)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    if( timeout < 0 )
    {
        tick_num = 0x7fffffff;          // 永远, 取个很大的值
    }
    else
    {
        tick_num = timeout;
    }
    
    tick1 = GetTickCount();

    for( ;; )
    {
        // 获取动子状态信息
        rtn = TSAP_axis_get_status_g(num, axis_list, status, NULL, NULL);
        
        // 判断是否停止
        if( OK == rtn )
        {
            stopped = TRUE;
            for( i = 0; i < num; i++ )
            {
                if( !tsxa_is_bit_set(status[i], 2) )        // bit2: moving
                {
                    stop_list[i] = TRUE;
                }
                stopped &= stop_list[i];
            }
            if( stopped )
            {
                break;
            }
        }
        
        tick2 = GetTickCount();
        // 防止tick数值32bit溢出
        tick = (int)tick2 - (int)tick1;
        if( abs( tick ) >= tick_num )
        {
            rtn = TSXA_TIMEOUT_ERROR;
            break;
        }
        
        Sleep(2);
    }
    return rtn;
}


int TSAP_get_mover_pos
        (
        IN      int     axis,
        OUT     double  *pos,
        OUT     double  *vel
        )
{
    int rtn = OK;
    double act_pos = 0.0;
    double act_vel = 0.0;

    rtn= TSAP_axis_get_status(axis, NULL, &act_pos, &act_vel);

    
    if( vel != NULL )
    {
        *vel = act_vel;
    }

    if( pos != NULL )
    {
        *pos = act_pos;
    }
    
    return rtn;
}


int TSAP_get_mover_pos_group
        (
        IN      int     num,
        IN      int     *axis_list,
        OUT     double  *pos_list
        )
{
    int rtn = OK;
    UINT16 mover_status_list[128] = { 0 };

    rtn= TSAP_axis_get_status_g(num, axis_list, mover_status_list, NULL, pos_list);

    return rtn;
}


int TSAP_set_motion_parameter
        (
        IN      int     axis,
        IN      double  vel,
        IN      double  acc,
        IN      double  dec
        )
{
    int rtn = OK;
    int addr = 0;
    UINT16 target_vel = 0;
    UINT16 target_acc = 0;
    UINT16 target_dec = 0;
    UINT32 data = 0;

    if( axis < 0 || axis > 127)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    target_vel = (UINT16)vel;
    target_acc = (UINT16)acc;
    target_dec = (UINT16)dec;

    data = (UINT32)target_vel << 16;

    addr = MOVER_CONTROL_ADDR + axis * 12;
    rtn = MIO_write_reg(addr, data);


    data = (UINT32)target_acc | ( (UINT32)target_dec << 16 );
    addr = MOVER_SET_ACC_ADDR + axis * 12;
    rtn = MIO_write_reg(addr, data);

    return rtn;
}


int TSAP_get_motion_parameter
        (
        IN      int     axis,
        OUT     double  *vel,
        OUT     double  *acc,
        OUT     double  *dec
        )
{
    int rtn = OK;
    int addr = 0;
    UINT16 data[6] = { 0 };
    UINT16 target_vel = 0;
    UINT16 target_acc = 0;
    UINT16 target_dec = 0;
    UINT16 target_jerk = 0;

    if( axis < 0 || axis > 127)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    addr = MOVER_CONTROL_ADDR + axis * 12;
    rtn = MIO_read_reg_shorts(addr, data, 6);       // 读取mover control整个数据

    target_vel = data[1];
    target_acc = data[4];
    target_dec = data[5];

    // 读取全局参数
    if( OK == rtn )
    {
        if( ( target_vel == 0 ) || ( target_acc == 0 ) || ( target_dec == 0 ) )
        {
            rtn = MIO_read_reg_shorts(0x1020, data, 6); 
        }
    }
    
    if( OK == rtn )
    {
        if( target_vel == 0 )
        {
            target_vel = data[1];
        }
        
        if( target_acc == 0 )
        {
            target_acc = data[2];
        }
        
        if( target_dec == 0 )
        {
            target_dec = data[3];
        }
    }

    if( OK == rtn )
    {
        if( vel != NULL )
        {
            *vel = (double)target_vel;
        }
        if( acc != NULL )
        {
            *acc = (double)target_acc;
        }
        if( dec != NULL )
        {
            *dec = (double)target_dec;
        }
    }
    return rtn;
}


int TSAP_set_global_motion_parameter
        (
        IN      double  vel,
        IN      double  acc,
        IN      double  dec
        )
{
    int rtn = OK;
    int addr = 0;
    UINT16 data[4] = { 0 };

    addr = 0x20;

    // 清一下最后一位
    data[0] = (UINT16)0;
    data[1] = (UINT16)vel;
    data[2] = (UINT16)acc;
    data[3] = (UINT16)dec;
    rtn = MIO_write_reg_shorts(addr, data, 4);

    Sleep(NIOS_SLEEP_TIME);

    data[0] = (UINT16)0;
    data[1] = (UINT16)vel + 1;      // 最后一位是上升沿才行
    data[2] = (UINT16)acc + 1;
    data[3] = (UINT16)dec + 1;
    rtn = MIO_write_reg_shorts(addr, data, 4);
    
    return rtn;
}


int TSAP_get_global_motion_parameter
        (
        OUT      double  *vel,
        OUT      double  *acc,
        OUT      double  *dec,
        OUT      double  *quick_stop_acc,
        OUT      double  *jerk
        )
{
    int rtn = OK;
    int addr = 0;
    UINT16 data[6] = { 0 };

    addr = 0x1020;
    rtn = MIO_read_reg_shorts(addr, data, 6);

    if( OK == rtn )
    {
        if( vel != NULL )
        {
            *vel = (double)data[1];
        }
        if( acc != NULL )
        {
            *acc = (double)data[2];
        }
        if( dec != NULL )
        {
            *dec = (double)data[3];
        }
        if( quick_stop_acc != NULL )
        {
            *quick_stop_acc = (double)data[4];
        }
        if( jerk != NULL )
        {
            *jerk = (double)data[5];
        }
    }
    return rtn;
}


int TSAP_axis_disable_all
        (
        IN      int num
        )
{
    int rtn = OK;
    UINT16 control = 0;
    int i = 0;
    int addr = 0;
    int size = 0;
    TSXA_MOVER_INPUT_struct mover[128] = { 0 };


    if( num < 0 || num > 127)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    // 获取所有动子的数据
    addr = MOVER_CONTROL_ADDR ;   // 动子从0开始
    size = sizeof(TSXA_MOVER_INPUT_struct) * num;
    rtn = MIO_read_reg_shorts(addr, (UINT16 *)mover, size / 2);

    // 参数填入
    if( OK == rtn )
    {
        for( i = 0; i < num; i++ )
        {
            mover[i].control = 0x1;        // clear control bit
        }
    }

    // 一起写入数据, clear control, set parameter
    if( OK == rtn )
    {
        if( num > 82 )    // 分2次发送
        {
            size = sizeof(TSXA_MOVER_INPUT_struct) * 82 / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size);

            addr = MOVER_CONTROL_ADDR + sizeof(TSXA_MOVER_INPUT_struct) * 82;
            size = sizeof(TSXA_MOVER_INPUT_struct) * (num - 82) / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)&mover[82].control, size);
        }
        else
        {
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size / 2);
        }
    }

    // delay
    Sleep(FPGA_SLEEP_TIME);

    // 一起写入数据, control bit2: servo off
    if( OK == rtn )
    {
        for( i = 0; i < num; i++ )
        {
            mover[i].control = 0x5;        // bit0, bit2
        }

        if( num > 82 )    // 分2次发送
        {
            size = sizeof(TSXA_MOVER_INPUT_struct) * 82 / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size);

            addr = MOVER_CONTROL_ADDR + sizeof(TSXA_MOVER_INPUT_struct) * 82;
            size = sizeof(TSXA_MOVER_INPUT_struct) * (num - 82) / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)&mover[82].control, size);
        }
        else
        {
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size / 2);
        }
    }

    // 一起写入数据, clear bit2
    if( OK == rtn )
    {
        Sleep(FPGA_SLEEP_TIME);
        for( i = 0; i < num; i++ )
        {
            mover[i].control = 0x1;        // bit0, clear bit2
        }

        if( num > 82 )    // 分2次发送
        {
            size = sizeof(TSXA_MOVER_INPUT_struct) * 82 / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size);

            addr = MOVER_CONTROL_ADDR + sizeof(TSXA_MOVER_INPUT_struct) * 82;
            size = sizeof(TSXA_MOVER_INPUT_struct) * (num - 82) / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)&mover[82].control, size);
        }
        else
        {
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size / 2);
        }
    }
    return rtn;
}


int TSAP_axis_enable_all
        (
        IN      int num
        )
{
    int rtn = OK;
    UINT16 control = 0;
    int i = 0;
    int addr = 0;
    int size = 0;
    TSXA_MOVER_INPUT_struct mover[128] = { 0 };

    if( num < 0 || num > 127)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    // 获取所有动子的数据
    addr = MOVER_CONTROL_ADDR ;                     // 动子从0开始
    size = sizeof(TSXA_MOVER_INPUT_struct) * num;
    rtn = MIO_read_reg_shorts(addr, (UINT16 *)mover, size / 2);

    // 参数填入
    if( OK == rtn )
    {
        for( i = 0; i < num; i++ )
        {
            mover[i].control = 0x1;        // clear control bit
        }
    }

    // 一起写入数据, clear control, set parameter
    if( OK == rtn )
    {
        if( num > 82 )    // 分2次发送
        {
            size = sizeof(TSXA_MOVER_INPUT_struct) * 82 / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size);

            addr = MOVER_CONTROL_ADDR + sizeof(TSXA_MOVER_INPUT_struct) * 82;
            size = sizeof(TSXA_MOVER_INPUT_struct) * (num - 82) / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)&mover[82].control, size);
        }
        else
        {
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size / 2);
        }
    }

    // delay
    Sleep(FPGA_SLEEP_TIME);

    // 一起写入数据, control bit1: servo on
    if( OK == rtn )
    {
        for( i = 0; i < num; i++ )
        {
            mover[i].control = 0x3;        // bit0, bit1
        }

        if( num > 82 )    // 分2次发送
        {
            size = sizeof(TSXA_MOVER_INPUT_struct) * 82 / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size);

            addr = MOVER_CONTROL_ADDR + sizeof(TSXA_MOVER_INPUT_struct) * 82;
            size = sizeof(TSXA_MOVER_INPUT_struct) * (num - 82) / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)&mover[82].control, size);
        }
        else
        {
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size / 2);
        }
    }

    // 一起写入数据, clear bit1
    if( OK == rtn )
    {
        Sleep(FPGA_SLEEP_TIME);
        for( i = 0; i < num; i++ )
        {
            mover[i].control = 0x1;        // bit0, clear bit1
        }

        if( num > 82 )    // 分2次发送
        {
            size = sizeof(TSXA_MOVER_INPUT_struct) * 82 / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size);

            addr = MOVER_CONTROL_ADDR + sizeof(TSXA_MOVER_INPUT_struct) * 82;
            size = sizeof(TSXA_MOVER_INPUT_struct) * (num - 82) / 2;
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)&mover[82].control, size);
        }
        else
        {
            rtn = MIO_write_reg_shorts(addr, (UINT16 *)mover, size / 2);
        }
    }
    return rtn;
}


int TSAP_st_get_all_mover_id
        (
        OUT     int *st_reached_num,
        OUT     int st_reached_id_list[32],
        OUT     int reaced_mover_id_list[32]
        )
{
    int rtn = 0;
    int axis = 0;
    UINT32 value[16] = { 0 };
    int i = 0;
    int num = 0;
    int axis_id[ACTIVE_STATION_NUM] = { 0 };
    int st_reached[ACTIVE_STATION_NUM] = { 0 };
    int mover_id[ACTIVE_STATION_NUM] = { 0 };

    // axis_id[]设置初始值, 0xfc表示没有动子
    for( i = 0; i < ACTIVE_STATION_NUM; i++ )
    {
        axis_id[i] = 0xfc;
    }

#if 0
    // 读取所有工位上的动子到位信息
    rtn = MIO_read_reg_longs(0x10c0, value, ACTIVE_STATION_NUM / 4);
    if( OK == rtn )
    {
        for( i = 0; i < ACTIVE_STATION_NUM / 4; i++ )
        {
            // 获取id
            axis_id[4*i] = value[i] & 0x000000ff;
            axis_id[4*i + 1] = ( value[i] & 0x0000ff00 ) >> 8;
            axis_id[4*i + 2] = ( value[i] & 0x00ff0000 ) >> 16;
            axis_id[4*i + 3] = ( value[i] & 0xff000000 ) >> 24;
        }
    }
#endif
    for( i = 0; i < ACTIVE_STATION_NUM; i++ )
    {
        axis_id[i] = g_mio_stn_status_reg.stn_reached_axis_id[i];
    }

    if( OK == rtn )
    {
        for( i = 0; i < ACTIVE_STATION_NUM; i++ )
        {
            if( ( axis_id[i] >= 0 ) && ( axis_id[i] != 0xfc ) )
            {
                 st_reached[num] = i;
                 mover_id[num] = axis_id[i];
                 num++;
            }
        }
    }

    if( OK == rtn )
    {
        if( st_reached_num != NULL )
        {
            *st_reached_num = num;
        }

        if( st_reached_id_list != NULL )
        {
            for( i = 0; i < num; i++ )
            {
                st_reached_id_list[i] = st_reached[i];
            }
        }

        if( reaced_mover_id_list != NULL )
        {
            for( i = 0; i < num; i++ )
            {
                reaced_mover_id_list[i] = mover_id[i];
            }
        }
    }


    rtn = g_TSAP_flush_stn_status;
    
    return rtn;
}


int TSAP_st_get_all_mover_id_32
        (
        OUT     int *st_reached_num,
        OUT     int st_reached_id_list[32],
        OUT     int reaced_mover_id_list[32]
        )
{
    int rtn = 0;
    int axis = 0;
    UINT32 value[16] = { 0 };
    int i = 0;
    int num = 0;
    int axis_id[ACTIVE_STATION_NUM] = { 0 };
    int st_reached[ACTIVE_STATION_NUM] = { 0 };
    int mover_id[ACTIVE_STATION_NUM] = { 0 };

    // axis_id[]设置初始值, 0xfc表示没有动子
    for( i = 0; i < ACTIVE_STATION_NUM; i++ )
    {
        axis_id[i] = 0xfc;
    }

#if 0
    // 读取32-63所有工位上的动子到位信息
    rtn = MIO_read_reg_longs(0x10e0, value, ACTIVE_STATION_NUM / 4);
    if( OK == rtn )
    {
        for( i = 0; i < ACTIVE_STATION_NUM / 4; i++ )
        {
            // 获取id
            axis_id[4*i] = value[i] & 0x000000ff;
            axis_id[4*i + 1] = ( value[i] & 0x0000ff00 ) >> 8;
            axis_id[4*i + 2] = ( value[i] & 0x00ff0000 ) >> 16;
            axis_id[4*i + 3] = ( value[i] & 0xff000000 ) >> 24;
        }
    }
#endif
    for( i = 0; i < ACTIVE_STATION_NUM; i++ )
    {
        axis_id[i] = g_mio_stn_status_reg.stn_reached_axis_id[i+32];
    }


    if( OK == rtn )
    {
        for( i = 0; i < ACTIVE_STATION_NUM; i++ )
        {
            if( ( axis_id[i] >= 0 ) && ( axis_id[i] != 0xfc ) )
            {
                 st_reached[num] = i + 32;    // 32号工位开始
                 mover_id[num] = axis_id[i];
                 num++;
            }
        }
    }

    if( OK == rtn )
    {
        if( st_reached_num != NULL )
        {
            *st_reached_num = num;
        }

        if( st_reached_id_list != NULL )
        {
            for( i = 0; i < num; i++ )
            {
                st_reached_id_list[i] = st_reached[i];
            }
        }

        if( reaced_mover_id_list != NULL )
        {
            for( i = 0; i < num; i++ )
            {
                reaced_mover_id_list[i] = mover_id[i];
            }
        }
    }

    rtn = g_TSAP_flush_stn_status;

    return rtn;
}


int TSAP_st_get_occupy
        (
        IN      int     st_id,
        OUT     BOOL    *has
        )
{
	int rtn = OK;
    UINT32 data = 0;
    int addr = 0;
    int bit_index = 0;
    BOOL occupied = FALSE;

    if( st_id > 0 && st_id < 32 )
    {
        addr = 0x1088;
        bit_index = st_id;
        data = g_mio_stn_status_reg.stn_occupied_0;
    }
    else if( st_id >= 32 && st_id < 64 )
    {
        addr = 0x108C;
        bit_index = st_id - 32;
        data = g_mio_stn_status_reg.stn_occupied_32;
    }
    else
    {
        rtn = TSXA_PARAMETER_ERROR;
    }

    if( OK == rtn )
    {
        //rtn = MIO_read_reg(addr, &data);
    }

    if( OK == rtn )
    {
        occupied = tsxa_is_bit_set(data, bit_index);
        rtn = g_TSAP_flush_stn_status;
    }

    if( has != NULL )
    {
        *has = occupied;
    }

    Sleep(1);
    
    return rtn;
}


int TSAP_st_set_allow_entering
        (
        IN      int     st_id,
        IN      BOOL    allow
        )
{
	int rtn = OK;
    int addr = 0;
    UINT32 value = 0;
    UINT32 st_value = 0;
    int id = 0;

    if( st_id < 0 || st_id > 63)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    if( st_id == 10 )
    {
        id = 60;
    }
    else if( st_id == 14 )
    {
        id = 61;
    }

    if( !allow )
    {
        rtn = TSAP_st_enable(id);
    }
    else
    {
        rtn = TSAP_st_disable(id);
    }
    
    return rtn;
}


int TSAP_get_sys_state
        (
        OUT     BOOL    *inited,
        OUT     BOOL    *autoworked
        )
{
    int rtn = 0;
    UINT32 status = 0;
    UINT32 sys_err = 0;
    BOOL sys_inited = FALSE;
    BOOL auto_worked = FALSE;
	UINT32 sys_errinfo = 0;

    rtn = TSAP_sys_get_status(&status, &sys_err, &sys_errinfo);
    if( OK == rtn )
    {
        // bit1 -inited   bit5 - quick stop  bit8 - error
        // inited ,  not quick stop,  no eror
        if( tsxa_is_bit_set(status, 1) && !tsxa_is_bit_set(status, 5) && !tsxa_is_bit_set(status, 8) )
        {
            sys_inited = TRUE;
        }

        // bit2 - auto worked   bit5 - quick stop  bit8 - error
        // autowork ,  not quick stop,  no eror
        if( tsxa_is_bit_set(status, 2) && !tsxa_is_bit_set(status, 5) && !tsxa_is_bit_set(status, 8) )
        {
           auto_worked = TRUE;
        }
    }

    if( inited != NULL )
    {
        *inited = sys_inited;
    }

    if( autoworked != NULL )
    {
        *autoworked = auto_worked;
    }

    Sleep(1);
    
    return rtn;
}


int TSAP_st_get_pos
        (
        IN      int     st_id,
        OUT     double  *pos
        )
{
	int rtn = OK;
    UINT32 data_write = 0;

    int addr = 0;
    UINT32 value = 0;
    double pos_val = 0.0;

    int addr_read = 0;
    int addr_write = 0;
    //int bit_index = 0;
    TSXA_SYS_STATION_OP_struct  data_read;
    int size = 0;

    if( st_id < 0 || st_id > 63)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

#if 0
    addr_write = 0x44;
    addr_read = 0x1044;

    if( OK == rtn )
    {
        data_write = st_id << 24;
        rtn = MIO_write_reg(addr_write, data_write);
    }
    
    if( OK == rtn )
    {
        size = sizeof(data_read) / 4;
        rtn = MIO_read_reg_longs(addr_read, (UINT32*)&data_read, size);
        if(rtn == OK)
        {
            *pos = (double)data_read.base_pos * 0.001;
        }
    }
#endif
    // station_pos:  0x7d00 - 0x7dff   station_pos_0-64 pos
    addr = 0x7d00 + st_id * 4;
    rtn = MIO_read_reg(addr, &value);
    if( OK == rtn )
    {
        pos_val = (double)((int)value ) * 0.001;
        if( pos != NULL )
        {
            *pos = pos_val;
        }
    }
    
    Sleep(5);
    
    return rtn;
}


int TSAP_st_limit
        (
        IN      int station_id,
        IN      BOOL station_op
        )
{
    int rtn = OK;
    int addr = 0;
    UINT32 value = 0;
    UINT32 st_value = 0;
    int id = 0;
    int station_act = 63;

#if 0
    if( station_id < 0 || station_id > 63)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    if(station_id == 19 || station_id == 20)
    {
        station_act = 60;
    }

//  直接操作station_op
    addr = 0x44;
    if( station_op )
    {
        value = ( (UINT32)( (UINT8)station_act ) << 24 ) | ( 0x20 << 16);   // op bit5 上升沿
        MIO_write_reg(addr, value); 
    }
    else
    {
        value = ( (UINT32)( (UINT8)station_act ) << 24 ) | ( 0x80 << 16);   // op bit7 上升沿
        MIO_write_reg(addr, value); 
    }
    if( OK == rtn )
    {
        Sleep(FPGA_SLEEP_TIME);
        MIO_write_reg(addr, 0x0);       // clear bits
    }

    Sleep(1);
 #endif
 
    return rtn;
}


int TSAP_mv_ison
        (
        IN      int     mover_id,
        OUT     int*    yes
        )
{
    int rtn = OK;
    int addr = 0;
    int size = 0;
    TSXA_MOVER_OUTPUT_struct  mover;
    UINT16 mv_status = 0;
    UINT16 son_mask = 0x2;
    UINT16 soff_mask = 0x4;
    *yes = -1;

    if( mover_id < 0 || mover_id > 127)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    addr = MOVER_STATUS_ADDR + mover_id * 8;
    size = sizeof(TSXA_MOVER_OUTPUT_struct) / 2;
    rtn = MIO_read_reg_shorts(addr, (UINT16 *)&mover, size);
    if(rtn == OK)
    {
        mv_status = mover.status;
        if(yes != NULL)
        {
            if(mv_status & son_mask)
            {
                *yes = 1;
                return rtn;
            }
            else
            {
                *yes = 0;
                return rtn;
            }
        }
    }
    
#if 0
    if( mover_status != NULL )
    {
        *mover_status = mover.status;
    }
    
    if( act_vel != NULL )
    {
        *act_vel = (double)mover.act_vel;
    }

    if( act_pos != NULL )
    {
        *act_pos = (double)mover.act_pos * 0.001;
    }
#endif    

    Sleep(1);

    return rtn;
}


int TSAP_st_set_station_pv
        (
                IN int id,
                IN double pos,
                IN double vel,
                IN BOOL save_to_flash                   // 是否保存到flash永久保存
        )
{
    int rtn = OK;
    int addr = 0;
    int size = 0;
    TSXA_SYS_STATION_OP_struct  data;
    UINT32 data_write = 0;
    int addr_read = 0;
    int addr_write = 0;

    if( id < 0 || id > 63)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

    addr_write = SYS_IN_STATION_PARA_ADDR;
    addr_read = 0x1044;

    if( OK == rtn )
    {
        data_write = id << 24;
        rtn = MIO_write_reg(addr_write, data_write);
    }
    
    if( OK == rtn )
    {
        size = sizeof(data) / 4;
        rtn = MIO_read_reg_longs(addr_read, (UINT32*)&data, size);
    }
    
    if( save_to_flash )
    {
        data.station_op = 0xf4;
    }
    else
    {
        data.station_op = 0x54;
    }
    data.base_pos = (INT32)( pos * 1000 );     // mm -> um
    if(vel != 0)
    {
        data.vel = (INT32)(vel);
    }
    
    size = sizeof(TSXA_SYS_STATION_OP_struct) / 4;

    // 写入数据
    rtn = MIO_write_reg_longs(addr_write, (UINT32 *)&data, size); 
    
    Sleep(NIOS_SLEEP_TIME);

    // op更新
    if( save_to_flash )
    {
        data.station_op = 0xf5;
    }
    else
    {
        data.station_op = 0x55;
    }
    rtn = MIO_write_reg_longs(addr_write, (UINT32 *)&data, size); 

    Sleep(1);

    return rtn;
}


int TSAP_st_act_limit
        (
        IN  int soft_limit_id,
        IN  BOOL limit_en
        )
{
    int rtn = OK;
    int addr = 0;
    UINT32 value = 0;
    UINT32 st_value = 0;
    int id = 0;
    char *func_name = "TSAP_st_act_limit";

    // 入口trace，需要人工检查修改
    DTXA_trace_t("TS", DTXA_TRACE_INT, func_name, "> (soft_limit_id = %d  limit_en = %d)" , soft_limit_id, limit_en);
    
    //int station_act = station_id;

    if( soft_limit_id < 0 || soft_limit_id > 63)
    {
        rtn = TSXA_PARAMETER_ERROR;
        return rtn;
    }

#if 0
    //  直接操作station_op
    addr = 0x44;
    if( limit_en )
    {
        value = ( (UINT32)( (UINT8)station_id ) << 24 ) | ( 0x20 << 16);   // op bit5 上升沿
        MIO_write_reg(addr, value); 
    }
    else
    {
        value = ( (UINT32)( (UINT8)station_id ) << 24 ) | ( 0x80 << 16);   // op bit7 上升沿
        MIO_write_reg(addr, value); 
    }
    if( OK == rtn )
    {
        Sleep(FPGA_SLEEP_TIME);
        MIO_write_reg(addr, 0x0);       // clear bits
    }

    Sleep(10);
#endif

    // soft_limit_en_0-31:  0x7e00   soft_limit_en,  bit4-31有效
    // soft_limit_en_32-63:  0x7e04   soft_limit_en,  bit4-31有效
    // soft_limit_dis_0-31:  0x7e08   soft_limit_dis,  bit4-31有效
    // soft_limit_dis_32-63:  0x7e0c   soft_limit_dis,  bit4-31有效
    if( soft_limit_id > 3 && soft_limit_id < 32 )
    {
        if( limit_en )
        {
            addr = 0x7e00;
        }
        else
        {
            addr = 0x7e08;
        }
        value = 0x1 << soft_limit_id;
    }
    else if( soft_limit_id > 31 && soft_limit_id < 64 )
    {
        if( limit_en )
        {
            addr = 0x7e04;
        }
        else
        {
            addr = 0x7e0c;
        }
        value = 0x1 << (soft_limit_id - 32);
    }
    
    rtn = MIO_write_reg(addr, 0x0);
    if( OK == rtn )
    {
        Sleep(FPGA_SLEEP_TIME);
        rtn = MIO_write_reg(addr, value);
    }
    Sleep(1);

    DTXA_trace_t("TS", DTXA_TRACE_INT, func_name, "> () = 0x%x" , rtn);

    return rtn;
}



// 刷新mio常用寄存器的线程
// 工位状态相关的寄存器一直刷新保存在全局变量里，外部有访问直接把全局变量的结果输出，减少多个线程访问mio寄存器的次数
void tsap_flush_mio_reg_t(void *dummy)
{
    int rtn = OK;
    UINT32 data[2] = { 0 };
    UINT32 value = 0;
    UINT32 stn_data[32] = { 0 };

    for(;;)
    {
        if( !g_network_initialized )
        {
            break;
        }

        g_TSAP_flush_sys_status_rtn = MIO_read_reg_longs(0x1000, data, 2);
        if( OK == g_TSAP_flush_sys_status_rtn)
        {
            g_mio_sys_status_reg = data[0];
            g_mio_sys_errno_reg = data[1];
        }
        Sleep(10);
        
        g_TSAP_flush_sys_status_rtn = MIO_read_reg(0x102c, &value);
        if( OK == g_TSAP_flush_sys_status_rtn )
        {
            g_mio_sys_errinfo_reg = value;
        }
        Sleep(10);
        
        // 0x1080开始工位状态相关寄存器
        g_TSAP_flush_stn_status = MIO_read_reg_longs(0x1080, stn_data, 32);
        if( OK == g_TSAP_flush_stn_status )
        {
            memcpy((void *)&g_mio_stn_status_reg, (void *)stn_data, sizeof(UINT32) * 32);
        }
        
        Sleep(10);
    }
    
}


// 启动读取MIO的工位状态寄存器的线程
int tsap_start_read_mio_reg_thread(void)
{
    int rtn = OK;

    _beginthread(tsap_flush_mio_reg_t, 0, NULL);

    return rtn;
}


